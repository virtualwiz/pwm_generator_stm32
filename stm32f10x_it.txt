; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\stm32f10x_it.o --asm_dir=.\ --list_dir=.\ --depend=.\obj\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_it.crf user\stm32f10x_it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NMI_Handler PROC
;;;62     
;;;63     void NMI_Handler(void)
000000  4770              BX       lr
;;;64     {
;;;65     }
;;;66     
                          ENDP

                  USART1_IRQHandler PROC
;;;67     void USART1_IRQHandler(void){
000002  b570              PUSH     {r4-r6,lr}
;;;68       unsigned int i;
;;;69       if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)	   //判断读寄存器是否非空
000004  f2405125          MOV      r1,#0x525
000008  4828              LDR      r0,|L1.172|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b360              CBZ      r0,|L1.106|
;;;70       {	
;;;71         RxBuffer1[RxCounter1++] = USART_ReceiveData(USART1);   //将读寄存器的数据缓存到接收缓冲区里
000010  4826              LDR      r0,|L1.172|
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c1              UXTB     r1,r0
000018  4825              LDR      r0,|L1.176|
00001a  7805              LDRB     r5,[r0,#0]  ; RxCounter1
00001c  1c68              ADDS     r0,r5,#1
00001e  4a24              LDR      r2,|L1.176|
000020  7010              STRB     r0,[r2,#0]
000022  4824              LDR      r0,|L1.180|
000024  5541              STRB     r1,[r0,r5]
;;;72     	
;;;73         if(RxBuffer1[RxCounter1-2]==0x0d&&RxBuffer1[RxCounter1-1]==0x0a)     //判断结束标志是否是0x0d 0x0a
000026  4610              MOV      r0,r2
000028  7800              LDRB     r0,[r0,#0]  ; RxCounter1
00002a  1e80              SUBS     r0,r0,#2
00002c  4921              LDR      r1,|L1.180|
00002e  5c08              LDRB     r0,[r1,r0]
000030  280d              CMP      r0,#0xd
000032  d11a              BNE      |L1.106|
000034  4610              MOV      r0,r2
000036  7800              LDRB     r0,[r0,#0]  ; RxCounter1
000038  1e40              SUBS     r0,r0,#1
00003a  5c08              LDRB     r0,[r1,r0]
00003c  280a              CMP      r0,#0xa
00003e  d114              BNE      |L1.106|
;;;74         {
;;;75     	  for(i=0; i< RxCounter1; i++) TxBuffer1[i]	= RxBuffer1[i]; 	     //将接收缓冲器的数据转到发送缓冲区，准备转发
000040  2400              MOVS     r4,#0
000042  e004              B        |L1.78|
                  |L1.68|
000044  481b              LDR      r0,|L1.180|
000046  5d00              LDRB     r0,[r0,r4]
000048  491b              LDR      r1,|L1.184|
00004a  5508              STRB     r0,[r1,r4]
00004c  1c64              ADDS     r4,r4,#1
                  |L1.78|
00004e  4818              LDR      r0,|L1.176|
000050  7800              LDRB     r0,[r0,#0]  ; RxCounter1
000052  4284              CMP      r4,r0
000054  d3f6              BCC      |L1.68|
;;;76     	  rec_f=1;															 //接收成功标志
000056  2001              MOVS     r0,#1
000058  4918              LDR      r1,|L1.188|
00005a  7008              STRB     r0,[r1,#0]
;;;77     	  TxBuffer1[RxCounter1]=0;		                                     //发送缓冲区结束符    
00005c  2000              MOVS     r0,#0
00005e  4916              LDR      r1,|L1.184|
000060  4a13              LDR      r2,|L1.176|
000062  7812              LDRB     r2,[r2,#0]  ; RxCounter1
000064  5488              STRB     r0,[r1,r2]
;;;78     	  RxCounter1=0;
000066  4912              LDR      r1,|L1.176|
000068  7008              STRB     r0,[r1,#0]
                  |L1.106|
;;;79     	  
;;;80         }
;;;81       }
;;;82       
;;;83       if(USART_GetITStatus(USART1, USART_IT_TXE) != RESET)                   //这段是为了避免STM32 USART 第一个字节发不出去的BUG 
00006a  f2407127          MOV      r1,#0x727
00006e  480f              LDR      r0,|L1.172|
000070  f7fffffe          BL       USART_GetITStatus
000074  b128              CBZ      r0,|L1.130|
;;;84       { 
;;;85          USART_ITConfig(USART1, USART_IT_TXE, DISABLE);					     //禁止发缓冲器空中断， 
000076  2200              MOVS     r2,#0
000078  f2407127          MOV      r1,#0x727
00007c  480b              LDR      r0,|L1.172|
00007e  f7fffffe          BL       USART_ITConfig
                  |L1.130|
;;;86       }	
;;;87     }
000082  bd70              POP      {r4-r6,pc}
;;;88     
                          ENDP

                  EXTI15_10_IRQHandler PROC
;;;89     void EXTI15_10_IRQHandler(){
000084  480e              LDR      r0,|L1.192|
;;;90     	EXTI ->PR |= 1 << 15;
000086  6800              LDR      r0,[r0,#0]
000088  f4404000          ORR      r0,r0,#0x8000
00008c  490c              LDR      r1,|L1.192|
00008e  6008              STR      r0,[r1,#0]
;;;91     }
000090  4770              BX       lr
;;;92     
                          ENDP

                  HardFault_Handler PROC
;;;98       */
;;;99     void HardFault_Handler(void)
000092  bf00              NOP      
                  |L1.148|
;;;100    {
;;;101      /* Go to infinite loop when Hard Fault exception occurs */
;;;102      while (1)
000094  e7fe              B        |L1.148|
;;;103      {
;;;104      }
;;;105    }
;;;106    
                          ENDP

                  MemManage_Handler PROC
;;;111      */
;;;112    void MemManage_Handler(void)
000096  bf00              NOP      
                  |L1.152|
;;;113    {
;;;114      /* Go to infinite loop when Memory Manage exception occurs */
;;;115      while (1)
000098  e7fe              B        |L1.152|
;;;116      {
;;;117      }
;;;118    }
;;;119    
                          ENDP

                  BusFault_Handler PROC
;;;124      */
;;;125    void BusFault_Handler(void)
00009a  bf00              NOP      
                  |L1.156|
;;;126    {
;;;127      /* Go to infinite loop when Bus Fault exception occurs */
;;;128      while (1)
00009c  e7fe              B        |L1.156|
;;;129      {
;;;130      }
;;;131    }
;;;132    
                          ENDP

                  UsageFault_Handler PROC
;;;137      */
;;;138    void UsageFault_Handler(void)
00009e  bf00              NOP      
                  |L1.160|
;;;139    {
;;;140      /* Go to infinite loop when Usage Fault exception occurs */
;;;141      while (1)
0000a0  e7fe              B        |L1.160|
;;;142      {
;;;143      }
;;;144    }
;;;145    
                          ENDP

                  SVC_Handler PROC
;;;150      */
;;;151    void SVC_Handler(void)
0000a2  4770              BX       lr
;;;152    {
;;;153    }
;;;154    
                          ENDP

                  DebugMon_Handler PROC
;;;159      */
;;;160    void DebugMon_Handler(void)
0000a4  4770              BX       lr
;;;161    {
;;;162    }
;;;163    
                          ENDP

                  PendSV_Handler PROC
;;;168      */
;;;169    void PendSV_Handler(void)
0000a6  4770              BX       lr
;;;170    {
;;;171    }
;;;172    
                          ENDP

                  SysTick_Handler PROC
;;;177      */
;;;178    void SysTick_Handler(void)
0000a8  4770              BX       lr
;;;179    {
;;;180    }
;;;181    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L1.172|
                          DCD      0x40013800
                  |L1.176|
                          DCD      RxCounter1
                  |L1.180|
                          DCD      RxBuffer1
                  |L1.184|
                          DCD      TxBuffer1
                  |L1.188|
                          DCD      rec_f
                  |L1.192|
                          DCD      0x40010414
