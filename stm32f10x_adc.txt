; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\stm32f10x_adc.o --asm_dir=.\ --list_dir=.\ --depend=.\obj\stm32f10x_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_adc.crf FWlib\SRC\stm32f10x_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;178      */
;;;179    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;180    {
000002  4604              MOV      r4,r0
;;;181      /* Check the parameters */
;;;182      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;183      switch (*(uint32_t*)&ADCx)
000004  48f7              LDR      r0,|L1.996|
000006  4420              ADD      r0,r0,r4
000008  b130              CBZ      r0,|L1.24|
00000a  f5b06f80          CMP      r0,#0x400
00000e  d00d              BEQ      |L1.44|
000010  f5b05fc0          CMP      r0,#0x1800
000014  d11e              BNE      |L1.84|
000016  e013              B        |L1.64|
                  |L1.24|
;;;184      {
;;;185        case ADC1_BASE:
;;;186          /* Enable ADC1 reset state */
;;;187          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  0248              LSLS     r0,r1,#9
00001c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;188          /* Release ADC1 from reset state */
;;;189          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
000020  2100              MOVS     r1,#0
000022  f44f7000          MOV      r0,#0x200
000026  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;190          break;
00002a  e014              B        |L1.86|
                  |L1.44|
;;;191        
;;;192        case ADC2_BASE:
;;;193          /* Enable ADC2 reset state */
;;;194          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
00002c  2101              MOVS     r1,#1
00002e  0288              LSLS     r0,r1,#10
000030  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;195          /* Release ADC2 from reset state */
;;;196          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
000034  2100              MOVS     r1,#0
000036  f44f6080          MOV      r0,#0x400
00003a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;197          break;
00003e  e00a              B        |L1.86|
                  |L1.64|
;;;198          
;;;199        case ADC3_BASE:
;;;200          /* Enable ADC3 reset state */
;;;201          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
000040  2101              MOVS     r1,#1
000042  03c8              LSLS     r0,r1,#15
000044  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;202          /* Release ADC3 from reset state */
;;;203          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
000048  2100              MOVS     r1,#0
00004a  f44f4000          MOV      r0,#0x8000
00004e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;204          break; 
000052  e000              B        |L1.86|
                  |L1.84|
;;;205        default:
;;;206          break;
000054  bf00              NOP      
                  |L1.86|
000056  bf00              NOP                            ;190
;;;207      }
;;;208    }
000058  bd10              POP      {r4,pc}
;;;209    
                          ENDP

                  ADC_Init PROC
;;;218      */
;;;219    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
00005a  b530              PUSH     {r4,r5,lr}
;;;220    {
00005c  4602              MOV      r2,r0
;;;221      uint32_t tmpreg1 = 0;
00005e  2000              MOVS     r0,#0
;;;222      uint8_t tmpreg2 = 0;
000060  2300              MOVS     r3,#0
;;;223      /* Check the parameters */
;;;224      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;225      assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
;;;226      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;227      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
;;;228      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
;;;229      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;230      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
;;;231      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;232      /* Get the ADCx CR1 value */
;;;233      tmpreg1 = ADCx->CR1;
000062  6850              LDR      r0,[r2,#4]
;;;234      /* Clear DUALMOD and SCAN bits */
;;;235      tmpreg1 &= CR1_CLEAR_Mask;
000064  4ce0              LDR      r4,|L1.1000|
000066  4020              ANDS     r0,r0,r4
;;;236      /* Configure ADCx: Dual mode and scan conversion mode */
;;;237      /* Set DUALMOD bits according to ADC_Mode value */
;;;238      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;239      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
000068  790d              LDRB     r5,[r1,#4]
00006a  680c              LDR      r4,[r1,#0]
00006c  ea442405          ORR      r4,r4,r5,LSL #8
000070  4320              ORRS     r0,r0,r4
;;;240      /* Write to ADCx CR1 */
;;;241      ADCx->CR1 = tmpreg1;
000072  6050              STR      r0,[r2,#4]
;;;242      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;243      /* Get the ADCx CR2 value */
;;;244      tmpreg1 = ADCx->CR2;
000074  6890              LDR      r0,[r2,#8]
;;;245      /* Clear CONT, ALIGN and EXTSEL bits */
;;;246      tmpreg1 &= CR2_CLEAR_Mask;
000076  4cdd              LDR      r4,|L1.1004|
000078  4020              ANDS     r0,r0,r4
;;;247      /* Configure ADCx: external trigger event and continuous conversion mode */
;;;248      /* Set ALIGN bit according to ADC_DataAlign value */
;;;249      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;250      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;251      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
00007a  e9d15402          LDRD     r5,r4,[r1,#8]
00007e  432c              ORRS     r4,r4,r5
000080  794d              LDRB     r5,[r1,#5]
000082  ea440445          ORR      r4,r4,r5,LSL #1
000086  4320              ORRS     r0,r0,r4
;;;252                ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;253      /* Write to ADCx CR2 */
;;;254      ADCx->CR2 = tmpreg1;
000088  6090              STR      r0,[r2,#8]
;;;255      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;256      /* Get the ADCx SQR1 value */
;;;257      tmpreg1 = ADCx->SQR1;
00008a  6ad0              LDR      r0,[r2,#0x2c]
;;;258      /* Clear L bits */
;;;259      tmpreg1 &= SQR1_CLEAR_Mask;
00008c  f4200070          BIC      r0,r0,#0xf00000
;;;260      /* Configure ADCx: regular channel sequence length */
;;;261      /* Set L bits according to ADC_NbrOfChannel value */
;;;262      tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
000090  7c0c              LDRB     r4,[r1,#0x10]
000092  1e64              SUBS     r4,r4,#1
000094  431c              ORRS     r4,r4,r3
000096  b2e3              UXTB     r3,r4
;;;263      tmpreg1 |= ((uint32_t)tmpreg2 << 20);
000098  ea405003          ORR      r0,r0,r3,LSL #20
;;;264      /* Write to ADCx SQR1 */
;;;265      ADCx->SQR1 = tmpreg1;
00009c  62d0              STR      r0,[r2,#0x2c]
;;;266    }
00009e  bd30              POP      {r4,r5,pc}
;;;267    
                          ENDP

                  ADC_StructInit PROC
;;;273      */
;;;274    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
0000a0  2100              MOVS     r1,#0
;;;275    {
;;;276      /* Reset ADC init structure parameters values */
;;;277      /* Initialize the ADC_Mode member */
;;;278      ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
0000a2  6001              STR      r1,[r0,#0]
;;;279      /* initialize the ADC_ScanConvMode member */
;;;280      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
0000a4  7101              STRB     r1,[r0,#4]
;;;281      /* Initialize the ADC_ContinuousConvMode member */
;;;282      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
0000a6  7141              STRB     r1,[r0,#5]
;;;283      /* Initialize the ADC_ExternalTrigConv member */
;;;284      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
0000a8  6081              STR      r1,[r0,#8]
;;;285      /* Initialize the ADC_DataAlign member */
;;;286      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
0000aa  60c1              STR      r1,[r0,#0xc]
;;;287      /* Initialize the ADC_NbrOfChannel member */
;;;288      ADC_InitStruct->ADC_NbrOfChannel = 1;
0000ac  2101              MOVS     r1,#1
0000ae  7401              STRB     r1,[r0,#0x10]
;;;289    }
0000b0  4770              BX       lr
;;;290    
                          ENDP

                  ADC_Cmd PROC
;;;297      */
;;;298    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0000b2  b121              CBZ      r1,|L1.190|
;;;299    {
;;;300      /* Check the parameters */
;;;301      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;302      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;303      if (NewState != DISABLE)
;;;304      {
;;;305        /* Set the ADON bit to wake up the ADC from power down mode */
;;;306        ADCx->CR2 |= CR2_ADON_Set;
0000b4  6882              LDR      r2,[r0,#8]
0000b6  f0420201          ORR      r2,r2,#1
0000ba  6082              STR      r2,[r0,#8]
0000bc  e003              B        |L1.198|
                  |L1.190|
;;;307      }
;;;308      else
;;;309      {
;;;310        /* Disable the selected ADC peripheral */
;;;311        ADCx->CR2 &= CR2_ADON_Reset;
0000be  6882              LDR      r2,[r0,#8]
0000c0  f0220201          BIC      r2,r2,#1
0000c4  6082              STR      r2,[r0,#8]
                  |L1.198|
;;;312      }
;;;313    }
0000c6  4770              BX       lr
;;;314    
                          ENDP

                  ADC_DMACmd PROC
;;;322      */
;;;323    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0000c8  b121              CBZ      r1,|L1.212|
;;;324    {
;;;325      /* Check the parameters */
;;;326      assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;327      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;328      if (NewState != DISABLE)
;;;329      {
;;;330        /* Enable the selected ADC DMA request */
;;;331        ADCx->CR2 |= CR2_DMA_Set;
0000ca  6882              LDR      r2,[r0,#8]
0000cc  f4427280          ORR      r2,r2,#0x100
0000d0  6082              STR      r2,[r0,#8]
0000d2  e003              B        |L1.220|
                  |L1.212|
;;;332      }
;;;333      else
;;;334      {
;;;335        /* Disable the selected ADC DMA request */
;;;336        ADCx->CR2 &= CR2_DMA_Reset;
0000d4  6882              LDR      r2,[r0,#8]
0000d6  f4227280          BIC      r2,r2,#0x100
0000da  6082              STR      r2,[r0,#8]
                  |L1.220|
;;;337      }
;;;338    }
0000dc  4770              BX       lr
;;;339    
                          ENDP

                  ADC_ITConfig PROC
;;;352      */
;;;353    void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
0000de  b510              PUSH     {r4,lr}
;;;354    {
;;;355      uint8_t itmask = 0;
0000e0  2300              MOVS     r3,#0
;;;356      /* Check the parameters */
;;;357      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;358      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;359      assert_param(IS_ADC_IT(ADC_IT));
;;;360      /* Get the ADC IT index */
;;;361      itmask = (uint8_t)ADC_IT;
0000e2  b2cb              UXTB     r3,r1
;;;362      if (NewState != DISABLE)
0000e4  b11a              CBZ      r2,|L1.238|
;;;363      {
;;;364        /* Enable the selected ADC interrupts */
;;;365        ADCx->CR1 |= itmask;
0000e6  6844              LDR      r4,[r0,#4]
0000e8  431c              ORRS     r4,r4,r3
0000ea  6044              STR      r4,[r0,#4]
0000ec  e002              B        |L1.244|
                  |L1.238|
;;;366      }
;;;367      else
;;;368      {
;;;369        /* Disable the selected ADC interrupts */
;;;370        ADCx->CR1 &= (~(uint32_t)itmask);
0000ee  6844              LDR      r4,[r0,#4]
0000f0  439c              BICS     r4,r4,r3
0000f2  6044              STR      r4,[r0,#4]
                  |L1.244|
;;;371      }
;;;372    }
0000f4  bd10              POP      {r4,pc}
;;;373    
                          ENDP

                  ADC_ResetCalibration PROC
;;;378      */
;;;379    void ADC_ResetCalibration(ADC_TypeDef* ADCx)
0000f6  6881              LDR      r1,[r0,#8]
;;;380    {
;;;381      /* Check the parameters */
;;;382      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;383      /* Resets the selected ADC calibartion registers */  
;;;384      ADCx->CR2 |= CR2_RSTCAL_Set;
0000f8  f0410108          ORR      r1,r1,#8
0000fc  6081              STR      r1,[r0,#8]
;;;385    }
0000fe  4770              BX       lr
;;;386    
                          ENDP

                  ADC_GetResetCalibrationStatus PROC
;;;391      */
;;;392    FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
000100  4601              MOV      r1,r0
;;;393    {
;;;394      FlagStatus bitstatus = RESET;
000102  2000              MOVS     r0,#0
;;;395      /* Check the parameters */
;;;396      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;397      /* Check the status of RSTCAL bit */
;;;398      if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
000104  688a              LDR      r2,[r1,#8]
000106  f0020208          AND      r2,r2,#8
00010a  b10a              CBZ      r2,|L1.272|
;;;399      {
;;;400        /* RSTCAL bit is set */
;;;401        bitstatus = SET;
00010c  2001              MOVS     r0,#1
00010e  e000              B        |L1.274|
                  |L1.272|
;;;402      }
;;;403      else
;;;404      {
;;;405        /* RSTCAL bit is reset */
;;;406        bitstatus = RESET;
000110  2000              MOVS     r0,#0
                  |L1.274|
;;;407      }
;;;408      /* Return the RSTCAL bit status */
;;;409      return  bitstatus;
;;;410    }
000112  4770              BX       lr
;;;411    
                          ENDP

                  ADC_StartCalibration PROC
;;;416      */
;;;417    void ADC_StartCalibration(ADC_TypeDef* ADCx)
000114  6881              LDR      r1,[r0,#8]
;;;418    {
;;;419      /* Check the parameters */
;;;420      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;421      /* Enable the selected ADC calibration process */  
;;;422      ADCx->CR2 |= CR2_CAL_Set;
000116  f0410104          ORR      r1,r1,#4
00011a  6081              STR      r1,[r0,#8]
;;;423    }
00011c  4770              BX       lr
;;;424    
                          ENDP

                  ADC_GetCalibrationStatus PROC
;;;429      */
;;;430    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
00011e  4601              MOV      r1,r0
;;;431    {
;;;432      FlagStatus bitstatus = RESET;
000120  2000              MOVS     r0,#0
;;;433      /* Check the parameters */
;;;434      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;435      /* Check the status of CAL bit */
;;;436      if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
000122  688a              LDR      r2,[r1,#8]
000124  f0020204          AND      r2,r2,#4
000128  b10a              CBZ      r2,|L1.302|
;;;437      {
;;;438        /* CAL bit is set: calibration on going */
;;;439        bitstatus = SET;
00012a  2001              MOVS     r0,#1
00012c  e000              B        |L1.304|
                  |L1.302|
;;;440      }
;;;441      else
;;;442      {
;;;443        /* CAL bit is reset: end of calibration */
;;;444        bitstatus = RESET;
00012e  2000              MOVS     r0,#0
                  |L1.304|
;;;445      }
;;;446      /* Return the CAL bit status */
;;;447      return  bitstatus;
;;;448    }
000130  4770              BX       lr
;;;449    
                          ENDP

                  ADC_SoftwareStartConvCmd PROC
;;;456      */
;;;457    void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000132  b121              CBZ      r1,|L1.318|
;;;458    {
;;;459      /* Check the parameters */
;;;460      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;461      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;462      if (NewState != DISABLE)
;;;463      {
;;;464        /* Enable the selected ADC conversion on external event and start the selected
;;;465           ADC conversion */
;;;466        ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
000134  6882              LDR      r2,[r0,#8]
000136  f44202a0          ORR      r2,r2,#0x500000
00013a  6082              STR      r2,[r0,#8]
00013c  e003              B        |L1.326|
                  |L1.318|
;;;467      }
;;;468      else
;;;469      {
;;;470        /* Disable the selected ADC conversion on external event and stop the selected
;;;471           ADC conversion */
;;;472        ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
00013e  6882              LDR      r2,[r0,#8]
000140  f42202a0          BIC      r2,r2,#0x500000
000144  6082              STR      r2,[r0,#8]
                  |L1.326|
;;;473      }
;;;474    }
000146  4770              BX       lr
;;;475    
                          ENDP

                  ADC_GetSoftwareStartConvStatus PROC
;;;480      */
;;;481    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000148  4601              MOV      r1,r0
;;;482    {
;;;483      FlagStatus bitstatus = RESET;
00014a  2000              MOVS     r0,#0
;;;484      /* Check the parameters */
;;;485      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;486      /* Check the status of SWSTART bit */
;;;487      if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
00014c  688a              LDR      r2,[r1,#8]
00014e  f4020280          AND      r2,r2,#0x400000
000152  b10a              CBZ      r2,|L1.344|
;;;488      {
;;;489        /* SWSTART bit is set */
;;;490        bitstatus = SET;
000154  2001              MOVS     r0,#1
000156  e000              B        |L1.346|
                  |L1.344|
;;;491      }
;;;492      else
;;;493      {
;;;494        /* SWSTART bit is reset */
;;;495        bitstatus = RESET;
000158  2000              MOVS     r0,#0
                  |L1.346|
;;;496      }
;;;497      /* Return the SWSTART bit status */
;;;498      return  bitstatus;
;;;499    }
00015a  4770              BX       lr
;;;500    
                          ENDP

                  ADC_DiscModeChannelCountConfig PROC
;;;508      */
;;;509    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
00015c  b510              PUSH     {r4,lr}
;;;510    {
00015e  460a              MOV      r2,r1
;;;511      uint32_t tmpreg1 = 0;
000160  2100              MOVS     r1,#0
;;;512      uint32_t tmpreg2 = 0;
000162  2300              MOVS     r3,#0
;;;513      /* Check the parameters */
;;;514      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;515      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;516      /* Get the old register value */
;;;517      tmpreg1 = ADCx->CR1;
000164  6841              LDR      r1,[r0,#4]
;;;518      /* Clear the old discontinuous mode channel count */
;;;519      tmpreg1 &= CR1_DISCNUM_Reset;
000166  f4214160          BIC      r1,r1,#0xe000
;;;520      /* Set the discontinuous mode channel count */
;;;521      tmpreg2 = Number - 1;
00016a  1e53              SUBS     r3,r2,#1
;;;522      tmpreg1 |= tmpreg2 << 13;
00016c  ea413143          ORR      r1,r1,r3,LSL #13
;;;523      /* Store the new register value */
;;;524      ADCx->CR1 = tmpreg1;
000170  6041              STR      r1,[r0,#4]
;;;525    }
000172  bd10              POP      {r4,pc}
;;;526    
                          ENDP

                  ADC_DiscModeCmd PROC
;;;535      */
;;;536    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000174  b121              CBZ      r1,|L1.384|
;;;537    {
;;;538      /* Check the parameters */
;;;539      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      if (NewState != DISABLE)
;;;542      {
;;;543        /* Enable the selected ADC regular discontinuous mode */
;;;544        ADCx->CR1 |= CR1_DISCEN_Set;
000176  6842              LDR      r2,[r0,#4]
000178  f4426200          ORR      r2,r2,#0x800
00017c  6042              STR      r2,[r0,#4]
00017e  e003              B        |L1.392|
                  |L1.384|
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Disable the selected ADC regular discontinuous mode */
;;;549        ADCx->CR1 &= CR1_DISCEN_Reset;
000180  6842              LDR      r2,[r0,#4]
000182  f4226200          BIC      r2,r2,#0x800
000186  6042              STR      r2,[r0,#4]
                  |L1.392|
;;;550      }
;;;551    }
000188  4770              BX       lr
;;;552    
                          ENDP

                  ADC_RegularChannelConfig PROC
;;;591      */
;;;592    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
00018a  b5f0              PUSH     {r4-r7,lr}
;;;593    {
00018c  4604              MOV      r4,r0
00018e  460d              MOV      r5,r1
;;;594      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000190  2000              MOVS     r0,#0
000192  2100              MOVS     r1,#0
;;;595      /* Check the parameters */
;;;596      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;597      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;598      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;599      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;600      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;601      if (ADC_Channel > ADC_Channel_9)
000194  2d09              CMP      r5,#9
000196  dd11              BLE      |L1.444|
;;;602      {
;;;603        /* Get the old register value */
;;;604        tmpreg1 = ADCx->SMPR1;
000198  68e0              LDR      r0,[r4,#0xc]
;;;605        /* Calculate the mask to clear */
;;;606        tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
00019a  f1a5060a          SUB      r6,r5,#0xa
00019e  eb060746          ADD      r7,r6,r6,LSL #1
0001a2  2607              MOVS     r6,#7
0001a4  fa06f107          LSL      r1,r6,r7
;;;607        /* Clear the old channel sample time */
;;;608        tmpreg1 &= ~tmpreg2;
0001a8  4388              BICS     r0,r0,r1
;;;609        /* Calculate the mask to set */
;;;610        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
0001aa  f1a5060a          SUB      r6,r5,#0xa
0001ae  eb060646          ADD      r6,r6,r6,LSL #1
0001b2  fa03f106          LSL      r1,r3,r6
;;;611        /* Set the new channel sample time */
;;;612        tmpreg1 |= tmpreg2;
0001b6  4308              ORRS     r0,r0,r1
;;;613        /* Store the new register value */
;;;614        ADCx->SMPR1 = tmpreg1;
0001b8  60e0              STR      r0,[r4,#0xc]
0001ba  e00c              B        |L1.470|
                  |L1.444|
;;;615      }
;;;616      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;617      {
;;;618        /* Get the old register value */
;;;619        tmpreg1 = ADCx->SMPR2;
0001bc  6920              LDR      r0,[r4,#0x10]
;;;620        /* Calculate the mask to clear */
;;;621        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
0001be  eb050745          ADD      r7,r5,r5,LSL #1
0001c2  2607              MOVS     r6,#7
0001c4  fa06f107          LSL      r1,r6,r7
;;;622        /* Clear the old channel sample time */
;;;623        tmpreg1 &= ~tmpreg2;
0001c8  4388              BICS     r0,r0,r1
;;;624        /* Calculate the mask to set */
;;;625        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
0001ca  eb050645          ADD      r6,r5,r5,LSL #1
0001ce  fa03f106          LSL      r1,r3,r6
;;;626        /* Set the new channel sample time */
;;;627        tmpreg1 |= tmpreg2;
0001d2  4308              ORRS     r0,r0,r1
;;;628        /* Store the new register value */
;;;629        ADCx->SMPR2 = tmpreg1;
0001d4  6120              STR      r0,[r4,#0x10]
                  |L1.470|
;;;630      }
;;;631      /* For Rank 1 to 6 */
;;;632      if (Rank < 7)
0001d6  2a07              CMP      r2,#7
0001d8  da0f              BGE      |L1.506|
;;;633      {
;;;634        /* Get the old register value */
;;;635        tmpreg1 = ADCx->SQR3;
0001da  6b60              LDR      r0,[r4,#0x34]
;;;636        /* Calculate the mask to clear */
;;;637        tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
0001dc  1e56              SUBS     r6,r2,#1
0001de  eb060786          ADD      r7,r6,r6,LSL #2
0001e2  261f              MOVS     r6,#0x1f
0001e4  fa06f107          LSL      r1,r6,r7
;;;638        /* Clear the old SQx bits for the selected rank */
;;;639        tmpreg1 &= ~tmpreg2;
0001e8  4388              BICS     r0,r0,r1
;;;640        /* Calculate the mask to set */
;;;641        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
0001ea  1e56              SUBS     r6,r2,#1
0001ec  eb060686          ADD      r6,r6,r6,LSL #2
0001f0  fa05f106          LSL      r1,r5,r6
;;;642        /* Set the SQx bits for the selected rank */
;;;643        tmpreg1 |= tmpreg2;
0001f4  4308              ORRS     r0,r0,r1
;;;644        /* Store the new register value */
;;;645        ADCx->SQR3 = tmpreg1;
0001f6  6360              STR      r0,[r4,#0x34]
0001f8  e022              B        |L1.576|
                  |L1.506|
;;;646      }
;;;647      /* For Rank 7 to 12 */
;;;648      else if (Rank < 13)
0001fa  2a0d              CMP      r2,#0xd
0001fc  da0f              BGE      |L1.542|
;;;649      {
;;;650        /* Get the old register value */
;;;651        tmpreg1 = ADCx->SQR2;
0001fe  6b20              LDR      r0,[r4,#0x30]
;;;652        /* Calculate the mask to clear */
;;;653        tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
000200  1fd6              SUBS     r6,r2,#7
000202  eb060786          ADD      r7,r6,r6,LSL #2
000206  261f              MOVS     r6,#0x1f
000208  fa06f107          LSL      r1,r6,r7
;;;654        /* Clear the old SQx bits for the selected rank */
;;;655        tmpreg1 &= ~tmpreg2;
00020c  4388              BICS     r0,r0,r1
;;;656        /* Calculate the mask to set */
;;;657        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
00020e  1fd6              SUBS     r6,r2,#7
000210  eb060686          ADD      r6,r6,r6,LSL #2
000214  fa05f106          LSL      r1,r5,r6
;;;658        /* Set the SQx bits for the selected rank */
;;;659        tmpreg1 |= tmpreg2;
000218  4308              ORRS     r0,r0,r1
;;;660        /* Store the new register value */
;;;661        ADCx->SQR2 = tmpreg1;
00021a  6320              STR      r0,[r4,#0x30]
00021c  e010              B        |L1.576|
                  |L1.542|
;;;662      }
;;;663      /* For Rank 13 to 16 */
;;;664      else
;;;665      {
;;;666        /* Get the old register value */
;;;667        tmpreg1 = ADCx->SQR1;
00021e  6ae0              LDR      r0,[r4,#0x2c]
;;;668        /* Calculate the mask to clear */
;;;669        tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
000220  f1a2060d          SUB      r6,r2,#0xd
000224  eb060786          ADD      r7,r6,r6,LSL #2
000228  261f              MOVS     r6,#0x1f
00022a  fa06f107          LSL      r1,r6,r7
;;;670        /* Clear the old SQx bits for the selected rank */
;;;671        tmpreg1 &= ~tmpreg2;
00022e  4388              BICS     r0,r0,r1
;;;672        /* Calculate the mask to set */
;;;673        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
000230  f1a2060d          SUB      r6,r2,#0xd
000234  eb060686          ADD      r6,r6,r6,LSL #2
000238  fa05f106          LSL      r1,r5,r6
;;;674        /* Set the SQx bits for the selected rank */
;;;675        tmpreg1 |= tmpreg2;
00023c  4308              ORRS     r0,r0,r1
;;;676        /* Store the new register value */
;;;677        ADCx->SQR1 = tmpreg1;
00023e  62e0              STR      r0,[r4,#0x2c]
                  |L1.576|
;;;678      }
;;;679    }
000240  bdf0              POP      {r4-r7,pc}
;;;680    
                          ENDP

                  ADC_ExternalTrigConvCmd PROC
;;;688      */
;;;689    void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000242  b121              CBZ      r1,|L1.590|
;;;690    {
;;;691      /* Check the parameters */
;;;692      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;693      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;694      if (NewState != DISABLE)
;;;695      {
;;;696        /* Enable the selected ADC conversion on external event */
;;;697        ADCx->CR2 |= CR2_EXTTRIG_Set;
000244  6882              LDR      r2,[r0,#8]
000246  f4421280          ORR      r2,r2,#0x100000
00024a  6082              STR      r2,[r0,#8]
00024c  e003              B        |L1.598|
                  |L1.590|
;;;698      }
;;;699      else
;;;700      {
;;;701        /* Disable the selected ADC conversion on external event */
;;;702        ADCx->CR2 &= CR2_EXTTRIG_Reset;
00024e  6882              LDR      r2,[r0,#8]
000250  f4221280          BIC      r2,r2,#0x100000
000254  6082              STR      r2,[r0,#8]
                  |L1.598|
;;;703      }
;;;704    }
000256  4770              BX       lr
;;;705    
                          ENDP

                  ADC_GetConversionValue PROC
;;;710      */
;;;711    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000258  4601              MOV      r1,r0
;;;712    {
;;;713      /* Check the parameters */
;;;714      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;715      /* Return the selected ADC conversion value */
;;;716      return (uint16_t) ADCx->DR;
00025a  6cc8              LDR      r0,[r1,#0x4c]
00025c  b280              UXTH     r0,r0
;;;717    }
00025e  4770              BX       lr
;;;718    
                          ENDP

                  ADC_GetDualModeConversionValue PROC
;;;722      */
;;;723    uint32_t ADC_GetDualModeConversionValue(void)
000260  4863              LDR      r0,|L1.1008|
;;;724    {
;;;725      /* Return the dual mode conversion value */
;;;726      return (*(__IO uint32_t *) DR_ADDRESS);
000262  6800              LDR      r0,[r0,#0]
;;;727    }
000264  4770              BX       lr
;;;728    
                          ENDP

                  ADC_AutoInjectedConvCmd PROC
;;;737      */
;;;738    void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000266  b121              CBZ      r1,|L1.626|
;;;739    {
;;;740      /* Check the parameters */
;;;741      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;742      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;743      if (NewState != DISABLE)
;;;744      {
;;;745        /* Enable the selected ADC automatic injected group conversion */
;;;746        ADCx->CR1 |= CR1_JAUTO_Set;
000268  6842              LDR      r2,[r0,#4]
00026a  f4426280          ORR      r2,r2,#0x400
00026e  6042              STR      r2,[r0,#4]
000270  e003              B        |L1.634|
                  |L1.626|
;;;747      }
;;;748      else
;;;749      {
;;;750        /* Disable the selected ADC automatic injected group conversion */
;;;751        ADCx->CR1 &= CR1_JAUTO_Reset;
000272  6842              LDR      r2,[r0,#4]
000274  f4226280          BIC      r2,r2,#0x400
000278  6042              STR      r2,[r0,#4]
                  |L1.634|
;;;752      }
;;;753    }
00027a  4770              BX       lr
;;;754    
                          ENDP

                  ADC_InjectedDiscModeCmd PROC
;;;763      */
;;;764    void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
00027c  b121              CBZ      r1,|L1.648|
;;;765    {
;;;766      /* Check the parameters */
;;;767      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;768      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;769      if (NewState != DISABLE)
;;;770      {
;;;771        /* Enable the selected ADC injected discontinuous mode */
;;;772        ADCx->CR1 |= CR1_JDISCEN_Set;
00027e  6842              LDR      r2,[r0,#4]
000280  f4425280          ORR      r2,r2,#0x1000
000284  6042              STR      r2,[r0,#4]
000286  e003              B        |L1.656|
                  |L1.648|
;;;773      }
;;;774      else
;;;775      {
;;;776        /* Disable the selected ADC injected discontinuous mode */
;;;777        ADCx->CR1 &= CR1_JDISCEN_Reset;
000288  6842              LDR      r2,[r0,#4]
00028a  f4225280          BIC      r2,r2,#0x1000
00028e  6042              STR      r2,[r0,#4]
                  |L1.656|
;;;778      }
;;;779    }
000290  4770              BX       lr
;;;780    
                          ENDP

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;816      */
;;;817    void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
000292  460a              MOV      r2,r1
;;;818    {
;;;819      uint32_t tmpreg = 0;
000294  2100              MOVS     r1,#0
;;;820      /* Check the parameters */
;;;821      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;822      assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;823      /* Get the old register value */
;;;824      tmpreg = ADCx->CR2;
000296  6881              LDR      r1,[r0,#8]
;;;825      /* Clear the old external event selection for injected group */
;;;826      tmpreg &= CR2_JEXTSEL_Reset;
000298  f42141e0          BIC      r1,r1,#0x7000
;;;827      /* Set the external event selection for injected group */
;;;828      tmpreg |= ADC_ExternalTrigInjecConv;
00029c  4311              ORRS     r1,r1,r2
;;;829      /* Store the new register value */
;;;830      ADCx->CR2 = tmpreg;
00029e  6081              STR      r1,[r0,#8]
;;;831    }
0002a0  4770              BX       lr
;;;832    
                          ENDP

                  ADC_ExternalTrigInjectedConvCmd PROC
;;;841      */
;;;842    void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0002a2  b121              CBZ      r1,|L1.686|
;;;843    {
;;;844      /* Check the parameters */
;;;845      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;846      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;847      if (NewState != DISABLE)
;;;848      {
;;;849        /* Enable the selected ADC external event selection for injected group */
;;;850        ADCx->CR2 |= CR2_JEXTTRIG_Set;
0002a4  6882              LDR      r2,[r0,#8]
0002a6  f4424200          ORR      r2,r2,#0x8000
0002aa  6082              STR      r2,[r0,#8]
0002ac  e003              B        |L1.694|
                  |L1.686|
;;;851      }
;;;852      else
;;;853      {
;;;854        /* Disable the selected ADC external event selection for injected group */
;;;855        ADCx->CR2 &= CR2_JEXTTRIG_Reset;
0002ae  6882              LDR      r2,[r0,#8]
0002b0  f4224200          BIC      r2,r2,#0x8000
0002b4  6082              STR      r2,[r0,#8]
                  |L1.694|
;;;856      }
;;;857    }
0002b6  4770              BX       lr
;;;858    
                          ENDP

                  ADC_SoftwareStartInjectedConvCmd PROC
;;;867      */
;;;868    void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
0002b8  b121              CBZ      r1,|L1.708|
;;;869    {
;;;870      /* Check the parameters */
;;;871      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;872      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;873      if (NewState != DISABLE)
;;;874      {
;;;875        /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;876           ADC injected conversion */
;;;877        ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
0002ba  6882              LDR      r2,[r0,#8]
0002bc  f4421202          ORR      r2,r2,#0x208000
0002c0  6082              STR      r2,[r0,#8]
0002c2  e003              B        |L1.716|
                  |L1.708|
;;;878      }
;;;879      else
;;;880      {
;;;881        /* Disable the selected ADC conversion on external event for injected group and stop the selected
;;;882           ADC injected conversion */
;;;883        ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
0002c4  6882              LDR      r2,[r0,#8]
0002c6  f4221202          BIC      r2,r2,#0x208000
0002ca  6082              STR      r2,[r0,#8]
                  |L1.716|
;;;884      }
;;;885    }
0002cc  4770              BX       lr
;;;886    
                          ENDP

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;891      */
;;;892    FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
0002ce  4601              MOV      r1,r0
;;;893    {
;;;894      FlagStatus bitstatus = RESET;
0002d0  2000              MOVS     r0,#0
;;;895      /* Check the parameters */
;;;896      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;897      /* Check the status of JSWSTART bit */
;;;898      if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
0002d2  688a              LDR      r2,[r1,#8]
0002d4  f4021200          AND      r2,r2,#0x200000
0002d8  b10a              CBZ      r2,|L1.734|
;;;899      {
;;;900        /* JSWSTART bit is set */
;;;901        bitstatus = SET;
0002da  2001              MOVS     r0,#1
0002dc  e000              B        |L1.736|
                  |L1.734|
;;;902      }
;;;903      else
;;;904      {
;;;905        /* JSWSTART bit is reset */
;;;906        bitstatus = RESET;
0002de  2000              MOVS     r0,#0
                  |L1.736|
;;;907      }
;;;908      /* Return the JSWSTART bit status */
;;;909      return  bitstatus;
;;;910    }
0002e0  4770              BX       lr
;;;911    
                          ENDP

                  ADC_InjectedChannelConfig PROC
;;;950      */
;;;951    void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
0002e2  b5f0              PUSH     {r4-r7,lr}
;;;952    {
0002e4  4604              MOV      r4,r0
0002e6  4615              MOV      r5,r2
;;;953      uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
0002e8  2000              MOVS     r0,#0
0002ea  2200              MOVS     r2,#0
0002ec  2600              MOVS     r6,#0
;;;954      /* Check the parameters */
;;;955      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;956      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;957      assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;958      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;959      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;960      if (ADC_Channel > ADC_Channel_9)
0002ee  2909              CMP      r1,#9
0002f0  dd11              BLE      |L1.790|
;;;961      {
;;;962        /* Get the old register value */
;;;963        tmpreg1 = ADCx->SMPR1;
0002f2  68e0              LDR      r0,[r4,#0xc]
;;;964        /* Calculate the mask to clear */
;;;965        tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
0002f4  f1a1070a          SUB      r7,r1,#0xa
0002f8  eb070c47          ADD      r12,r7,r7,LSL #1
0002fc  2707              MOVS     r7,#7
0002fe  fa07f20c          LSL      r2,r7,r12
;;;966        /* Clear the old channel sample time */
;;;967        tmpreg1 &= ~tmpreg2;
000302  4390              BICS     r0,r0,r2
;;;968        /* Calculate the mask to set */
;;;969        tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
000304  f1a1070a          SUB      r7,r1,#0xa
000308  eb070747          ADD      r7,r7,r7,LSL #1
00030c  fa03f207          LSL      r2,r3,r7
;;;970        /* Set the new channel sample time */
;;;971        tmpreg1 |= tmpreg2;
000310  4310              ORRS     r0,r0,r2
;;;972        /* Store the new register value */
;;;973        ADCx->SMPR1 = tmpreg1;
000312  60e0              STR      r0,[r4,#0xc]
000314  e00c              B        |L1.816|
                  |L1.790|
;;;974      }
;;;975      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;976      {
;;;977        /* Get the old register value */
;;;978        tmpreg1 = ADCx->SMPR2;
000316  6920              LDR      r0,[r4,#0x10]
;;;979        /* Calculate the mask to clear */
;;;980        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000318  eb010c41          ADD      r12,r1,r1,LSL #1
00031c  2707              MOVS     r7,#7
00031e  fa07f20c          LSL      r2,r7,r12
;;;981        /* Clear the old channel sample time */
;;;982        tmpreg1 &= ~tmpreg2;
000322  4390              BICS     r0,r0,r2
;;;983        /* Calculate the mask to set */
;;;984        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000324  eb010741          ADD      r7,r1,r1,LSL #1
000328  fa03f207          LSL      r2,r3,r7
;;;985        /* Set the new channel sample time */
;;;986        tmpreg1 |= tmpreg2;
00032c  4310              ORRS     r0,r0,r2
;;;987        /* Store the new register value */
;;;988        ADCx->SMPR2 = tmpreg1;
00032e  6120              STR      r0,[r4,#0x10]
                  |L1.816|
;;;989      }
;;;990      /* Rank configuration */
;;;991      /* Get the old register value */
;;;992      tmpreg1 = ADCx->JSQR;
000330  6ba0              LDR      r0,[r4,#0x38]
;;;993      /* Get JL value: Number = JL+1 */
;;;994      tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
000332  f3c05601          UBFX     r6,r0,#20,#2
;;;995      /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;996      tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000336  1cef              ADDS     r7,r5,#3
000338  f1060c01          ADD      r12,r6,#1
00033c  eba7070c          SUB      r7,r7,r12
000340  eb070c87          ADD      r12,r7,r7,LSL #2
000344  271f              MOVS     r7,#0x1f
000346  fa07f20c          LSL      r2,r7,r12
;;;997      /* Clear the old JSQx bits for the selected rank */
;;;998      tmpreg1 &= ~tmpreg2;
00034a  4390              BICS     r0,r0,r2
;;;999      /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;1000     tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
00034c  1cef              ADDS     r7,r5,#3
00034e  f1060c01          ADD      r12,r6,#1
000352  eba7070c          SUB      r7,r7,r12
000356  eb070787          ADD      r7,r7,r7,LSL #2
00035a  fa01f207          LSL      r2,r1,r7
;;;1001     /* Set the JSQx bits for the selected rank */
;;;1002     tmpreg1 |= tmpreg2;
00035e  4310              ORRS     r0,r0,r2
;;;1003     /* Store the new register value */
;;;1004     ADCx->JSQR = tmpreg1;
000360  63a0              STR      r0,[r4,#0x38]
;;;1005   }
000362  bdf0              POP      {r4-r7,pc}
;;;1006   
                          ENDP

                  ADC_InjectedSequencerLengthConfig PROC
;;;1013     */
;;;1014   void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
000364  b510              PUSH     {r4,lr}
;;;1015   {
000366  460a              MOV      r2,r1
;;;1016     uint32_t tmpreg1 = 0;
000368  2100              MOVS     r1,#0
;;;1017     uint32_t tmpreg2 = 0;
00036a  2300              MOVS     r3,#0
;;;1018     /* Check the parameters */
;;;1019     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1020     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1021     
;;;1022     /* Get the old register value */
;;;1023     tmpreg1 = ADCx->JSQR;
00036c  6b81              LDR      r1,[r0,#0x38]
;;;1024     /* Clear the old injected sequnence lenght JL bits */
;;;1025     tmpreg1 &= JSQR_JL_Reset;
00036e  f4211140          BIC      r1,r1,#0x300000
;;;1026     /* Set the injected sequnence lenght JL bits */
;;;1027     tmpreg2 = Length - 1; 
000372  1e53              SUBS     r3,r2,#1
;;;1028     tmpreg1 |= tmpreg2 << 20;
000374  ea415103          ORR      r1,r1,r3,LSL #20
;;;1029     /* Store the new register value */
;;;1030     ADCx->JSQR = tmpreg1;
000378  6381              STR      r1,[r0,#0x38]
;;;1031   }
00037a  bd10              POP      {r4,pc}
;;;1032   
                          ENDP

                  ADC_SetInjectedOffset PROC
;;;1046     */
;;;1047   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
00037c  5042              STR      r2,[r0,r1]
;;;1048   {
;;;1049     /* Check the parameters */
;;;1050     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1051     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1052     assert_param(IS_ADC_OFFSET(Offset));  
;;;1053     /* Set the selected injected channel data offset */
;;;1054     *((__IO uint32_t *)((*(uint32_t*)&ADCx) + ADC_InjectedChannel)) = (uint32_t)Offset;
;;;1055   }
00037e  4770              BX       lr
;;;1056   
                          ENDP

                  ADC_GetInjectedConversionValue PROC
;;;1067     */
;;;1068   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
000380  4602              MOV      r2,r0
;;;1069   {
;;;1070     /* Check the parameters */
;;;1071     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1072     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1073     /* Returns the selected injected channel conversion data value */
;;;1074     return (uint16_t) (*(__IO uint32_t*) (((*(uint32_t*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
000382  1850              ADDS     r0,r2,r1
000384  6a80              LDR      r0,[r0,#0x28]
000386  b280              UXTH     r0,r0
;;;1075   }
000388  4770              BX       lr
;;;1076   
                          ENDP

                  ADC_AnalogWatchdogCmd PROC
;;;1098     */
;;;1099   void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
00038a  460a              MOV      r2,r1
;;;1100   {
;;;1101     uint32_t tmpreg = 0;
00038c  2100              MOVS     r1,#0
;;;1102     /* Check the parameters */
;;;1103     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1104     assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;1105     /* Get the old register value */
;;;1106     tmpreg = ADCx->CR1;
00038e  6841              LDR      r1,[r0,#4]
;;;1107     /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;1108     tmpreg &= CR1_AWDMode_Reset;
000390  4b18              LDR      r3,|L1.1012|
000392  4019              ANDS     r1,r1,r3
;;;1109     /* Set the analog watchdog enable mode */
;;;1110     tmpreg |= ADC_AnalogWatchdog;
000394  4311              ORRS     r1,r1,r2
;;;1111     /* Store the new register value */
;;;1112     ADCx->CR1 = tmpreg;
000396  6041              STR      r1,[r0,#4]
;;;1113   }
000398  4770              BX       lr
;;;1114   
                          ENDP

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;1123     */
;;;1124   void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
00039a  6241              STR      r1,[r0,#0x24]
;;;1125                                           uint16_t LowThreshold)
;;;1126   {
;;;1127     /* Check the parameters */
;;;1128     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1129     assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;1130     assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;1131     /* Set the ADCx high threshold */
;;;1132     ADCx->HTR = HighThreshold;
;;;1133     /* Set the ADCx low threshold */
;;;1134     ADCx->LTR = LowThreshold;
00039c  6282              STR      r2,[r0,#0x28]
;;;1135   }
00039e  4770              BX       lr
;;;1136   
                          ENDP

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;1162     */
;;;1163   void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
0003a0  460a              MOV      r2,r1
;;;1164   {
;;;1165     uint32_t tmpreg = 0;
0003a2  2100              MOVS     r1,#0
;;;1166     /* Check the parameters */
;;;1167     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1168     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1169     /* Get the old register value */
;;;1170     tmpreg = ADCx->CR1;
0003a4  6841              LDR      r1,[r0,#4]
;;;1171     /* Clear the Analog watchdog channel select bits */
;;;1172     tmpreg &= CR1_AWDCH_Reset;
0003a6  f021011f          BIC      r1,r1,#0x1f
;;;1173     /* Set the Analog watchdog channel */
;;;1174     tmpreg |= ADC_Channel;
0003aa  4311              ORRS     r1,r1,r2
;;;1175     /* Store the new register value */
;;;1176     ADCx->CR1 = tmpreg;
0003ac  6041              STR      r1,[r0,#4]
;;;1177   }
0003ae  4770              BX       lr
;;;1178   
                          ENDP

                  ADC_TempSensorVrefintCmd PROC
;;;1184     */
;;;1185   void ADC_TempSensorVrefintCmd(FunctionalState NewState)
0003b0  b140              CBZ      r0,|L1.964|
;;;1186   {
;;;1187     /* Check the parameters */
;;;1188     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1189     if (NewState != DISABLE)
;;;1190     {
;;;1191       /* Enable the temperature sensor and Vrefint channel*/
;;;1192       ADC1->CR2 |= CR2_TSVREFE_Set;
0003b2  490f              LDR      r1,|L1.1008|
0003b4  3944              SUBS     r1,r1,#0x44
0003b6  6809              LDR      r1,[r1,#0]
0003b8  f4410100          ORR      r1,r1,#0x800000
0003bc  4a0c              LDR      r2,|L1.1008|
0003be  3a44              SUBS     r2,r2,#0x44
0003c0  6011              STR      r1,[r2,#0]
0003c2  e007              B        |L1.980|
                  |L1.964|
;;;1193     }
;;;1194     else
;;;1195     {
;;;1196       /* Disable the temperature sensor and Vrefint channel*/
;;;1197       ADC1->CR2 &= CR2_TSVREFE_Reset;
0003c4  490a              LDR      r1,|L1.1008|
0003c6  3944              SUBS     r1,r1,#0x44
0003c8  6809              LDR      r1,[r1,#0]
0003ca  f4210100          BIC      r1,r1,#0x800000
0003ce  4a08              LDR      r2,|L1.1008|
0003d0  3a44              SUBS     r2,r2,#0x44
0003d2  6011              STR      r1,[r2,#0]
                  |L1.980|
;;;1198     }
;;;1199   }
0003d4  4770              BX       lr
;;;1200   
                          ENDP

                  ADC_GetFlagStatus PROC
;;;1212     */
;;;1213   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
0003d6  4602              MOV      r2,r0
;;;1214   {
;;;1215     FlagStatus bitstatus = RESET;
0003d8  2000              MOVS     r0,#0
;;;1216     /* Check the parameters */
;;;1217     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1218     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1219     /* Check the status of the specified ADC flag */
;;;1220     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
0003da  6813              LDR      r3,[r2,#0]
0003dc  400b              ANDS     r3,r3,r1
0003de  b15b              CBZ      r3,|L1.1016|
;;;1221     {
;;;1222       /* ADC_FLAG is set */
;;;1223       bitstatus = SET;
0003e0  2001              MOVS     r0,#1
0003e2  e00a              B        |L1.1018|
                  |L1.996|
                          DCD      0xbffedc00
                  |L1.1000|
                          DCD      0xfff0feff
                  |L1.1004|
                          DCD      0xfff1f7fd
                  |L1.1008|
                          DCD      0x4001244c
                  |L1.1012|
                          DCD      0xff3ffdff
                  |L1.1016|
;;;1224     }
;;;1225     else
;;;1226     {
;;;1227       /* ADC_FLAG is reset */
;;;1228       bitstatus = RESET;
0003f8  2000              MOVS     r0,#0
                  |L1.1018|
;;;1229     }
;;;1230     /* Return the ADC_FLAG status */
;;;1231     return  bitstatus;
;;;1232   }
0003fa  4770              BX       lr
;;;1233   
                          ENDP

                  ADC_ClearFlag PROC
;;;1245     */
;;;1246   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
0003fc  43ca              MVNS     r2,r1
;;;1247   {
;;;1248     /* Check the parameters */
;;;1249     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1250     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1251     /* Clear the selected ADC flags */
;;;1252     ADCx->SR = ~(uint32_t)ADC_FLAG;
0003fe  6002              STR      r2,[r0,#0]
;;;1253   }
000400  4770              BX       lr
;;;1254   
                          ENDP

                  ADC_GetITStatus PROC
;;;1264     */
;;;1265   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000402  b570              PUSH     {r4-r6,lr}
;;;1266   {
000404  4602              MOV      r2,r0
;;;1267     ITStatus bitstatus = RESET;
000406  2000              MOVS     r0,#0
;;;1268     uint32_t itmask = 0, enablestatus = 0;
000408  2300              MOVS     r3,#0
00040a  2400              MOVS     r4,#0
;;;1269     /* Check the parameters */
;;;1270     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1271     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;1272     /* Get the ADC IT index */
;;;1273     itmask = ADC_IT >> 8;
00040c  120b              ASRS     r3,r1,#8
;;;1274     /* Get the ADC_IT enable bit status */
;;;1275     enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
00040e  6855              LDR      r5,[r2,#4]
000410  b2ce              UXTB     r6,r1
000412  ea050406          AND      r4,r5,r6
;;;1276     /* Check the status of the specified ADC interrupt */
;;;1277     if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
000416  6815              LDR      r5,[r2,#0]
000418  401d              ANDS     r5,r5,r3
00041a  b115              CBZ      r5,|L1.1058|
00041c  b10c              CBZ      r4,|L1.1058|
;;;1278     {
;;;1279       /* ADC_IT is set */
;;;1280       bitstatus = SET;
00041e  2001              MOVS     r0,#1
000420  e000              B        |L1.1060|
                  |L1.1058|
;;;1281     }
;;;1282     else
;;;1283     {
;;;1284       /* ADC_IT is reset */
;;;1285       bitstatus = RESET;
000422  2000              MOVS     r0,#0
                  |L1.1060|
;;;1286     }
;;;1287     /* Return the ADC_IT status */
;;;1288     return  bitstatus;
;;;1289   }
000424  bd70              POP      {r4-r6,pc}
;;;1290   
                          ENDP

                  ADC_ClearITPendingBit PROC
;;;1300     */
;;;1301   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000426  2200              MOVS     r2,#0
;;;1302   {
;;;1303     uint8_t itmask = 0;
;;;1304     /* Check the parameters */
;;;1305     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1306     assert_param(IS_ADC_IT(ADC_IT));
;;;1307     /* Get the ADC IT index */
;;;1308     itmask = (uint8_t)(ADC_IT >> 8);
000428  120a              ASRS     r2,r1,#8
;;;1309     /* Clear the selected ADC interrupt pending bits */
;;;1310     ADCx->SR = ~(uint32_t)itmask;
00042a  43d3              MVNS     r3,r2
00042c  6003              STR      r3,[r0,#0]
;;;1311   }
00042e  4770              BX       lr
;;;1312   
                          ENDP

