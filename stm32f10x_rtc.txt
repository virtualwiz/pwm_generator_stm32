; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\stm32f10x_rtc.o --asm_dir=.\ --list_dir=.\ --depend=.\obj\stm32f10x_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_rtc.crf FWlib\SRC\stm32f10x_rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;92       */
;;;93     void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L1.14|
;;;94     {
;;;95       /* Check the parameters */
;;;96       assert_param(IS_RTC_IT(RTC_IT));  
;;;97       assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;98       
;;;99       if (NewState != DISABLE)
;;;100      {
;;;101        RTC->CRH |= RTC_IT;
000002  4a50              LDR      r2,|L1.324|
000004  8812              LDRH     r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b4e              LDR      r3,|L1.324|
00000a  801a              STRH     r2,[r3,#0]
00000c  e004              B        |L1.24|
                  |L1.14|
;;;102      }
;;;103      else
;;;104      {
;;;105        RTC->CRH &= (uint16_t)~RTC_IT;
00000e  4a4d              LDR      r2,|L1.324|
000010  8812              LDRH     r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b4b              LDR      r3,|L1.324|
000016  801a              STRH     r2,[r3,#0]
                  |L1.24|
;;;106      }
;;;107    }
000018  4770              BX       lr
;;;108    
                          ENDP

                  RTC_EnterConfigMode PROC
;;;113      */
;;;114    void RTC_EnterConfigMode(void)
00001a  484a              LDR      r0,|L1.324|
;;;115    {
;;;116      /* Set the CNF flag to enter in the Configuration Mode */
;;;117      RTC->CRL |= CRL_CNF_Set;
00001c  1d00              ADDS     r0,r0,#4
00001e  8800              LDRH     r0,[r0,#0]
000020  f0400010          ORR      r0,r0,#0x10
000024  4947              LDR      r1,|L1.324|
000026  1d09              ADDS     r1,r1,#4
000028  8008              STRH     r0,[r1,#0]
;;;118    }
00002a  4770              BX       lr
;;;119    
                          ENDP

                  RTC_ExitConfigMode PROC
;;;124      */
;;;125    void RTC_ExitConfigMode(void)
00002c  4845              LDR      r0,|L1.324|
;;;126    {
;;;127      /* Reset the CNF flag to exit from the Configuration Mode */
;;;128      RTC->CRL &= CRL_CNF_Reset;
00002e  1d00              ADDS     r0,r0,#4
000030  8800              LDRH     r0,[r0,#0]
000032  f64f71ef          MOV      r1,#0xffef
000036  4008              ANDS     r0,r0,r1
000038  4942              LDR      r1,|L1.324|
00003a  1d09              ADDS     r1,r1,#4
00003c  8008              STRH     r0,[r1,#0]
;;;129    }
00003e  4770              BX       lr
;;;130    
                          ENDP

                  RTC_GetCounter PROC
;;;135      */
;;;136    uint32_t RTC_GetCounter(void)
000040  2100              MOVS     r1,#0
;;;137    {
;;;138      uint16_t tmp = 0;
;;;139      tmp = RTC->CNTL;
000042  4840              LDR      r0,|L1.324|
000044  301c              ADDS     r0,r0,#0x1c
000046  8801              LDRH     r1,[r0,#0]
;;;140      return (((uint32_t)RTC->CNTH << 16 ) | tmp) ;
000048  1f00              SUBS     r0,r0,#4
00004a  8800              LDRH     r0,[r0,#0]
00004c  ea414000          ORR      r0,r1,r0,LSL #16
;;;141    }
000050  4770              BX       lr
;;;142    
                          ENDP

                  RTC_SetCounter PROC
;;;147      */
;;;148    void RTC_SetCounter(uint32_t CounterValue)
000052  b500              PUSH     {lr}
;;;149    { 
000054  4602              MOV      r2,r0
;;;150      RTC_EnterConfigMode();
000056  f7fffffe          BL       RTC_EnterConfigMode
;;;151      /* Set RTC COUNTER MSB word */
;;;152      RTC->CNTH = CounterValue >> 16;
00005a  0c10              LSRS     r0,r2,#16
00005c  4939              LDR      r1,|L1.324|
00005e  3118              ADDS     r1,r1,#0x18
000060  8008              STRH     r0,[r1,#0]
;;;153      /* Set RTC COUNTER LSB word */
;;;154      RTC->CNTL = (CounterValue & RTC_LSB_Mask);
000062  1d09              ADDS     r1,r1,#4
000064  800a              STRH     r2,[r1,#0]
;;;155      RTC_ExitConfigMode();
000066  f7fffffe          BL       RTC_ExitConfigMode
;;;156    }
00006a  bd00              POP      {pc}
;;;157    
                          ENDP

                  RTC_SetPrescaler PROC
;;;162      */
;;;163    void RTC_SetPrescaler(uint32_t PrescalerValue)
00006c  b500              PUSH     {lr}
;;;164    {
00006e  4602              MOV      r2,r0
;;;165      /* Check the parameters */
;;;166      assert_param(IS_RTC_PRESCALER(PrescalerValue));
;;;167      
;;;168      RTC_EnterConfigMode();
000070  f7fffffe          BL       RTC_EnterConfigMode
;;;169      /* Set RTC PRESCALER MSB word */
;;;170      RTC->PRLH = (PrescalerValue & PRLH_MSB_Mask) >> 16;
000074  f3c24003          UBFX     r0,r2,#16,#4
000078  4932              LDR      r1,|L1.324|
00007a  3108              ADDS     r1,r1,#8
00007c  8008              STRH     r0,[r1,#0]
;;;171      /* Set RTC PRESCALER LSB word */
;;;172      RTC->PRLL = (PrescalerValue & RTC_LSB_Mask);
00007e  1d09              ADDS     r1,r1,#4
000080  800a              STRH     r2,[r1,#0]
;;;173      RTC_ExitConfigMode();
000082  f7fffffe          BL       RTC_ExitConfigMode
;;;174    }
000086  bd00              POP      {pc}
;;;175    
                          ENDP

                  RTC_SetAlarm PROC
;;;180      */
;;;181    void RTC_SetAlarm(uint32_t AlarmValue)
000088  b500              PUSH     {lr}
;;;182    {  
00008a  4602              MOV      r2,r0
;;;183      RTC_EnterConfigMode();
00008c  f7fffffe          BL       RTC_EnterConfigMode
;;;184      /* Set the ALARM MSB word */
;;;185      RTC->ALRH = AlarmValue >> 16;
000090  0c10              LSRS     r0,r2,#16
000092  492c              LDR      r1,|L1.324|
000094  3120              ADDS     r1,r1,#0x20
000096  8008              STRH     r0,[r1,#0]
;;;186      /* Set the ALARM LSB word */
;;;187      RTC->ALRL = (AlarmValue & RTC_LSB_Mask);
000098  1d09              ADDS     r1,r1,#4
00009a  800a              STRH     r2,[r1,#0]
;;;188      RTC_ExitConfigMode();
00009c  f7fffffe          BL       RTC_ExitConfigMode
;;;189    }
0000a0  bd00              POP      {pc}
;;;190    
                          ENDP

                  RTC_GetDivider PROC
;;;195      */
;;;196    uint32_t RTC_GetDivider(void)
0000a2  2000              MOVS     r0,#0
;;;197    {
;;;198      uint32_t tmp = 0x00;
;;;199      tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
0000a4  4927              LDR      r1,|L1.324|
0000a6  3110              ADDS     r1,r1,#0x10
0000a8  8809              LDRH     r1,[r1,#0]
0000aa  0709              LSLS     r1,r1,#28
0000ac  0b08              LSRS     r0,r1,#12
;;;200      tmp |= RTC->DIVL;
0000ae  4925              LDR      r1,|L1.324|
0000b0  3114              ADDS     r1,r1,#0x14
0000b2  8809              LDRH     r1,[r1,#0]
0000b4  4308              ORRS     r0,r0,r1
;;;201      return tmp;
;;;202    }
0000b6  4770              BX       lr
;;;203    
                          ENDP

                  RTC_WaitForLastTask PROC
;;;209      */
;;;210    void RTC_WaitForLastTask(void)
0000b8  bf00              NOP      
                  |L1.186|
;;;211    {
;;;212      /* Loop until RTOFF flag is set */
;;;213      while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
0000ba  4822              LDR      r0,|L1.324|
0000bc  1d00              ADDS     r0,r0,#4
0000be  8800              LDRH     r0,[r0,#0]
0000c0  f0000020          AND      r0,r0,#0x20
0000c4  2800              CMP      r0,#0
0000c6  d0f8              BEQ      |L1.186|
;;;214      {
;;;215      }
;;;216    }
0000c8  4770              BX       lr
;;;217    
                          ENDP

                  RTC_WaitForSynchro PROC
;;;225      */
;;;226    void RTC_WaitForSynchro(void)
0000ca  481e              LDR      r0,|L1.324|
;;;227    {
;;;228      /* Clear RSF flag */
;;;229      RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
0000cc  1d00              ADDS     r0,r0,#4
0000ce  8800              LDRH     r0,[r0,#0]
0000d0  f64f71f7          MOV      r1,#0xfff7
0000d4  4008              ANDS     r0,r0,r1
0000d6  491b              LDR      r1,|L1.324|
0000d8  1d09              ADDS     r1,r1,#4
0000da  8008              STRH     r0,[r1,#0]
;;;230      /* Loop until RSF flag is set */
;;;231      while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
0000dc  bf00              NOP      
                  |L1.222|
0000de  4819              LDR      r0,|L1.324|
0000e0  1d00              ADDS     r0,r0,#4
0000e2  8800              LDRH     r0,[r0,#0]
0000e4  f0000008          AND      r0,r0,#8
0000e8  2800              CMP      r0,#0
0000ea  d0f8              BEQ      |L1.222|
;;;232      {
;;;233      }
;;;234    }
0000ec  4770              BX       lr
;;;235    
                          ENDP

                  RTC_GetFlagStatus PROC
;;;246      */
;;;247    FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)
0000ee  4601              MOV      r1,r0
;;;248    {
;;;249      FlagStatus bitstatus = RESET;
0000f0  2000              MOVS     r0,#0
;;;250      
;;;251      /* Check the parameters */
;;;252      assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
;;;253      
;;;254      if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)
0000f2  4a14              LDR      r2,|L1.324|
0000f4  1d12              ADDS     r2,r2,#4
0000f6  8812              LDRH     r2,[r2,#0]
0000f8  400a              ANDS     r2,r2,r1
0000fa  b10a              CBZ      r2,|L1.256|
;;;255      {
;;;256        bitstatus = SET;
0000fc  2001              MOVS     r0,#1
0000fe  e000              B        |L1.258|
                  |L1.256|
;;;257      }
;;;258      else
;;;259      {
;;;260        bitstatus = RESET;
000100  2000              MOVS     r0,#0
                  |L1.258|
;;;261      }
;;;262      return bitstatus;
;;;263    }
000102  4770              BX       lr
;;;264    
                          ENDP

                  RTC_ClearFlag PROC
;;;275      */
;;;276    void RTC_ClearFlag(uint16_t RTC_FLAG)
000104  490f              LDR      r1,|L1.324|
;;;277    {
;;;278      /* Check the parameters */
;;;279      assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
;;;280        
;;;281      /* Clear the coressponding RTC flag */
;;;282      RTC->CRL &= (uint16_t)~RTC_FLAG;
000106  1d09              ADDS     r1,r1,#4
000108  8809              LDRH     r1,[r1,#0]
00010a  4381              BICS     r1,r1,r0
00010c  4a0d              LDR      r2,|L1.324|
00010e  1d12              ADDS     r2,r2,#4
000110  8011              STRH     r1,[r2,#0]
;;;283    }
000112  4770              BX       lr
;;;284    
                          ENDP

                  RTC_GetITStatus PROC
;;;293      */
;;;294    ITStatus RTC_GetITStatus(uint16_t RTC_IT)
000114  4601              MOV      r1,r0
;;;295    {
;;;296      ITStatus bitstatus = RESET;
000116  2000              MOVS     r0,#0
;;;297      /* Check the parameters */
;;;298      assert_param(IS_RTC_GET_IT(RTC_IT)); 
;;;299      
;;;300      bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
000118  4a0a              LDR      r2,|L1.324|
00011a  1d12              ADDS     r2,r2,#4
00011c  8812              LDRH     r2,[r2,#0]
00011e  400a              ANDS     r2,r2,r1
000120  b2d0              UXTB     r0,r2
;;;301      if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
000122  4a08              LDR      r2,|L1.324|
000124  8812              LDRH     r2,[r2,#0]
000126  400a              ANDS     r2,r2,r1
000128  b112              CBZ      r2,|L1.304|
00012a  b108              CBZ      r0,|L1.304|
;;;302      {
;;;303        bitstatus = SET;
00012c  2001              MOVS     r0,#1
00012e  e000              B        |L1.306|
                  |L1.304|
;;;304      }
;;;305      else
;;;306      {
;;;307        bitstatus = RESET;
000130  2000              MOVS     r0,#0
                  |L1.306|
;;;308      }
;;;309      return bitstatus;
;;;310    }
000132  4770              BX       lr
;;;311    
                          ENDP

                  RTC_ClearITPendingBit PROC
;;;320      */
;;;321    void RTC_ClearITPendingBit(uint16_t RTC_IT)
000134  4903              LDR      r1,|L1.324|
;;;322    {
;;;323      /* Check the parameters */
;;;324      assert_param(IS_RTC_IT(RTC_IT));  
;;;325      
;;;326      /* Clear the coressponding RTC pending bit */
;;;327      RTC->CRL &= (uint16_t)~RTC_IT;
000136  1d09              ADDS     r1,r1,#4
000138  8809              LDRH     r1,[r1,#0]
00013a  4381              BICS     r1,r1,r0
00013c  4a01              LDR      r2,|L1.324|
00013e  1d12              ADDS     r2,r2,#4
000140  8011              STRH     r1,[r2,#0]
;;;328    }
000142  4770              BX       lr
;;;329    
                          ENDP

                  |L1.324|
                          DCD      0x40002800
