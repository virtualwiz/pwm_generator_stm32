; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\stm32f10x_tim.o --asm_dir=.\ --list_dir=.\ --depend=.\obj\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_tim.crf FWlib\SRC\stm32f10x_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;187      */
;;;188    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;189    {
000002  4604              MOV      r4,r0
;;;190      /* Check the parameters */
;;;191      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;192     
;;;193      switch (*(uint32_t*)&TIMx)
000004  49f7              LDR      r1,|L1.996|
000006  1a60              SUBS     r0,r4,r1
000008  428c              CMP      r4,r1
00000a  d045              BEQ      |L1.152|
00000c  dc0c              BGT      |L1.40|
00000e  f1b44f80          CMP      r4,#0x40000000
000012  d01d              BEQ      |L1.80|
000014  48f4              LDR      r0,|L1.1000|
000016  4420              ADD      r0,r0,r4
000018  b318              CBZ      r0,|L1.98|
00001a  f5b06f80          CMP      r0,#0x400
00001e  d029              BEQ      |L1.116|
000020  f5b06f00          CMP      r0,#0x800
000024  d154              BNE      |L1.208|
000026  e02e              B        |L1.134|
                  |L1.40|
000028  f5b06f80          CMP      r0,#0x400
00002c  d03d              BEQ      |L1.170|
00002e  f5b03f8e          CMP      r0,#0x11c00
000032  d003              BEQ      |L1.60|
000034  f5b03f92          CMP      r0,#0x12400
000038  d14a              BNE      |L1.208|
00003a  e03f              B        |L1.188|
                  |L1.60|
;;;194      {
;;;195        case TIM1_BASE:
;;;196          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  02c8              LSLS     r0,r1,#11
000040  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;197          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000044  2100              MOVS     r1,#0
000046  f44f6000          MOV      r0,#0x800
00004a  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;198          break; 
00004e  e040              B        |L1.210|
                  |L1.80|
;;;199          
;;;200        case TIM2_BASE:
;;;201          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
000050  2101              MOVS     r1,#1
000052  4608              MOV      r0,r1
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;202          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
000058  2100              MOVS     r1,#0
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;203          break;
000060  e037              B        |L1.210|
                  |L1.98|
;;;204     
;;;205        case TIM3_BASE:
;;;206          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000062  2101              MOVS     r1,#1
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;207          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00006a  2100              MOVS     r1,#0
00006c  2002              MOVS     r0,#2
00006e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;208          break;
000072  e02e              B        |L1.210|
                  |L1.116|
;;;209     
;;;210        case TIM4_BASE:
;;;211          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000074  2101              MOVS     r1,#1
000076  2004              MOVS     r0,#4
000078  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;212          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00007c  2100              MOVS     r1,#0
00007e  2004              MOVS     r0,#4
000080  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;213          break;
000084  e025              B        |L1.210|
                  |L1.134|
;;;214          
;;;215        case TIM5_BASE:
;;;216          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000086  2101              MOVS     r1,#1
000088  2008              MOVS     r0,#8
00008a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;217          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
00008e  2100              MOVS     r1,#0
000090  2008              MOVS     r0,#8
000092  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;218          break;
000096  e01c              B        |L1.210|
                  |L1.152|
;;;219          
;;;220        case TIM6_BASE:
;;;221          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000098  2101              MOVS     r1,#1
00009a  2010              MOVS     r0,#0x10
00009c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;222          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
0000a0  2100              MOVS     r1,#0
0000a2  2010              MOVS     r0,#0x10
0000a4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;223          break;
0000a8  e013              B        |L1.210|
                  |L1.170|
;;;224          
;;;225        case TIM7_BASE:
;;;226          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  2020              MOVS     r0,#0x20
0000ae  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;227          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
0000b2  2100              MOVS     r1,#0
0000b4  2020              MOVS     r0,#0x20
0000b6  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;228          break;
0000ba  e00a              B        |L1.210|
                  |L1.188|
;;;229          
;;;230        case TIM8_BASE:
;;;231          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
0000bc  2101              MOVS     r1,#1
0000be  0348              LSLS     r0,r1,#13
0000c0  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;232          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
0000c4  2100              MOVS     r1,#0
0000c6  f44f5000          MOV      r0,#0x2000
0000ca  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;233          break; 
0000ce  e000              B        |L1.210|
                  |L1.208|
;;;234          
;;;235        default:
;;;236          break;
0000d0  bf00              NOP      
                  |L1.210|
0000d2  bf00              NOP                            ;198
;;;237      }
;;;238    }
0000d4  bd10              POP      {r4,pc}
;;;239    
                          ENDP

                  TIM_TimeBaseInit PROC
;;;249      */
;;;250    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
0000d6  8802              LDRH     r2,[r0,#0]
;;;251    {
;;;252      /* Check the parameters */
;;;253      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;254      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;255      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;256      /* Select the Counter Mode and set the clock division */
;;;257      TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
0000d8  f002028f          AND      r2,r2,#0x8f
0000dc  8002              STRH     r2,[r0,#0]
;;;258      TIMx->CR1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision |
0000de  88ca              LDRH     r2,[r1,#6]
0000e0  884b              LDRH     r3,[r1,#2]
0000e2  431a              ORRS     r2,r2,r3
0000e4  8803              LDRH     r3,[r0,#0]
0000e6  431a              ORRS     r2,r2,r3
0000e8  8002              STRH     r2,[r0,#0]
;;;259                    TIM_TimeBaseInitStruct->TIM_CounterMode;
;;;260      
;;;261      /* Set the Autoreload value */
;;;262      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
0000ea  888a              LDRH     r2,[r1,#4]
0000ec  8582              STRH     r2,[r0,#0x2c]
;;;263     
;;;264      /* Set the Prescaler value */
;;;265      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
0000ee  880a              LDRH     r2,[r1,#0]
0000f0  8502              STRH     r2,[r0,#0x28]
;;;266        
;;;267      if (((*(uint32_t*)&TIMx) == TIM1_BASE) || ((*(uint32_t*)&TIMx) == TIM8_BASE))  
0000f2  4abe              LDR      r2,|L1.1004|
0000f4  4290              CMP      r0,r2
0000f6  d002              BEQ      |L1.254|
0000f8  4abd              LDR      r2,|L1.1008|
0000fa  4290              CMP      r0,r2
0000fc  d101              BNE      |L1.258|
                  |L1.254|
;;;268      {
;;;269        /* Set the Repetition Counter value */
;;;270        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
0000fe  7a0a              LDRB     r2,[r1,#8]
000100  8602              STRH     r2,[r0,#0x30]
                  |L1.258|
;;;271      }
;;;272    
;;;273      /* Generate an update event to reload the Prescaler value immediatly */
;;;274      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
000102  2201              MOVS     r2,#1
000104  8282              STRH     r2,[r0,#0x14]
;;;275    }
000106  4770              BX       lr
;;;276    
                          ENDP

                  TIM_OC1Init PROC
;;;286      */
;;;287    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000108  b570              PUSH     {r4-r6,lr}
;;;288    {
;;;289      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
00010a  2400              MOVS     r4,#0
00010c  2200              MOVS     r2,#0
00010e  2300              MOVS     r3,#0
;;;290       
;;;291      /* Check the parameters */
;;;292      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;293      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;294      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;295      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;296      /* Disable the Channel 1: Reset the CC1E Bit */
;;;297      TIMx->CCER &= CCER_CC1E_Reset;
000110  8c05              LDRH     r5,[r0,#0x20]
000112  f64f76fe          MOV      r6,#0xfffe
000116  4035              ANDS     r5,r5,r6
000118  8405              STRH     r5,[r0,#0x20]
;;;298      
;;;299      /* Get the TIMx CCER register value */
;;;300      tmpccer = TIMx->CCER;
00011a  8c02              LDRH     r2,[r0,#0x20]
;;;301      /* Get the TIMx CR2 register value */
;;;302      tmpcr2 =  TIMx->CR2;
00011c  8883              LDRH     r3,[r0,#4]
;;;303      
;;;304      /* Get the TIMx CCMR1 register value */
;;;305      tmpccmrx = TIMx->CCMR1;
00011e  8b04              LDRH     r4,[r0,#0x18]
;;;306        
;;;307      /* Reset the Output Compare Mode Bits */
;;;308      tmpccmrx &= CCMR_OC13M_Mask;
000120  f64f758f          MOV      r5,#0xff8f
000124  402c              ANDS     r4,r4,r5
;;;309      
;;;310      /* Select the Output Compare Mode */
;;;311      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000126  880d              LDRH     r5,[r1,#0]
000128  432c              ORRS     r4,r4,r5
;;;312      
;;;313      /* Reset the Output Polarity level */
;;;314      tmpccer &= CCER_CC1P_Reset;
00012a  1e75              SUBS     r5,r6,#1
00012c  402a              ANDS     r2,r2,r5
;;;315      /* Set the Output Compare Polarity */
;;;316      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00012e  890d              LDRH     r5,[r1,#8]
000130  432a              ORRS     r2,r2,r5
;;;317      
;;;318      /* Set the Output State */
;;;319      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000132  884d              LDRH     r5,[r1,#2]
000134  432a              ORRS     r2,r2,r5
;;;320      
;;;321      /* Set the Capture Compare Register value */
;;;322      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000136  88cd              LDRH     r5,[r1,#6]
000138  8685              STRH     r5,[r0,#0x34]
;;;323      
;;;324      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
00013a  4dac              LDR      r5,|L1.1004|
00013c  42a8              CMP      r0,r5
00013e  d002              BEQ      |L1.326|
000140  4dab              LDR      r5,|L1.1008|
000142  42a8              CMP      r0,r5
000144  d113              BNE      |L1.366|
                  |L1.326|
;;;325      {
;;;326        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;327        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;328        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;329        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;330        
;;;331        /* Reset the Output N Polarity level */
;;;332        tmpccer &= CCER_CC1NP_Reset;
000146  f64f75f7          MOV      r5,#0xfff7
00014a  402a              ANDS     r2,r2,r5
;;;333        /* Set the Output N Polarity */
;;;334        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
00014c  894d              LDRH     r5,[r1,#0xa]
00014e  432a              ORRS     r2,r2,r5
;;;335        /* Reset the Output N State */
;;;336        tmpccer &= CCER_CC1NE_Reset;
000150  f64f75fb          MOV      r5,#0xfffb
000154  402a              ANDS     r2,r2,r5
;;;337        
;;;338        /* Set the Output N State */
;;;339        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000156  888d              LDRH     r5,[r1,#4]
000158  432a              ORRS     r2,r2,r5
;;;340        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;341        tmpcr2 &= CR2_OIS1_Reset;
00015a  f64765ff          MOV      r5,#0x7eff
00015e  402b              ANDS     r3,r3,r5
;;;342        tmpcr2 &= CR2_OIS1N_Reset;
000160  f64755ff          MOV      r5,#0x7dff
000164  402b              ANDS     r3,r3,r5
;;;343        /* Set the Output Idle state */
;;;344        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000166  898d              LDRH     r5,[r1,#0xc]
000168  432b              ORRS     r3,r3,r5
;;;345        /* Set the Output N Idle state */
;;;346        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
00016a  89cd              LDRH     r5,[r1,#0xe]
00016c  432b              ORRS     r3,r3,r5
                  |L1.366|
;;;347      }
;;;348      /* Write to TIMx CR2 */
;;;349      TIMx->CR2 = tmpcr2;
00016e  8083              STRH     r3,[r0,#4]
;;;350      
;;;351      /* Write to TIMx CCMR1 */
;;;352      TIMx->CCMR1 = tmpccmrx;
000170  8304              STRH     r4,[r0,#0x18]
;;;353      
;;;354      /* Write to TIMx CCER */
;;;355      TIMx->CCER = tmpccer;
000172  8402              STRH     r2,[r0,#0x20]
;;;356    }
000174  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP

                  TIM_OC2Init PROC
;;;367      */
;;;368    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000176  b570              PUSH     {r4-r6,lr}
;;;369    {
;;;370      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000178  2400              MOVS     r4,#0
00017a  2200              MOVS     r2,#0
00017c  2300              MOVS     r3,#0
;;;371       
;;;372      /* Check the parameters */
;;;373      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;374      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;375      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;376      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;377      /* Disable the Channel 2: Reset the CC2E Bit */
;;;378      TIMx->CCER &= CCER_CC2E_Reset;
00017e  8c05              LDRH     r5,[r0,#0x20]
000180  f64f76ef          MOV      r6,#0xffef
000184  4035              ANDS     r5,r5,r6
000186  8405              STRH     r5,[r0,#0x20]
;;;379      
;;;380      /* Get the TIMx CCER register value */  
;;;381      tmpccer = TIMx->CCER;
000188  8c02              LDRH     r2,[r0,#0x20]
;;;382      /* Get the TIMx CR2 register value */
;;;383      tmpcr2 =  TIMx->CR2;
00018a  8883              LDRH     r3,[r0,#4]
;;;384      
;;;385      /* Get the TIMx CCMR1 register value */
;;;386      tmpccmrx = TIMx->CCMR1;
00018c  8b04              LDRH     r4,[r0,#0x18]
;;;387        
;;;388      /* Reset the Output Compare Mode Bits */
;;;389      tmpccmrx &= CCMR_OC24M_Mask;
00018e  f64875ff          MOV      r5,#0x8fff
000192  402c              ANDS     r4,r4,r5
;;;390      
;;;391      /* Select the Output Compare Mode */
;;;392      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000194  880d              LDRH     r5,[r1,#0]
000196  f64f76ff          MOV      r6,#0xffff
00019a  ea062505          AND      r5,r6,r5,LSL #8
00019e  432c              ORRS     r4,r4,r5
;;;393      
;;;394      /* Reset the Output Polarity level */
;;;395      tmpccer &= CCER_CC2P_Reset;
0001a0  f64f75df          MOV      r5,#0xffdf
0001a4  402a              ANDS     r2,r2,r5
;;;396      /* Set the Output Compare Polarity */
;;;397      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
0001a6  890d              LDRH     r5,[r1,#8]
0001a8  ea061505          AND      r5,r6,r5,LSL #4
0001ac  432a              ORRS     r2,r2,r5
;;;398      
;;;399      /* Set the Output State */
;;;400      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
0001ae  884d              LDRH     r5,[r1,#2]
0001b0  ea061505          AND      r5,r6,r5,LSL #4
0001b4  432a              ORRS     r2,r2,r5
;;;401      
;;;402      /* Set the Capture Compare Register value */
;;;403      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
0001b6  88cd              LDRH     r5,[r1,#6]
0001b8  8705              STRH     r5,[r0,#0x38]
;;;404      
;;;405      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
0001ba  4d8c              LDR      r5,|L1.1004|
0001bc  42a8              CMP      r0,r5
0001be  d002              BEQ      |L1.454|
0001c0  4d8b              LDR      r5,|L1.1008|
0001c2  42a8              CMP      r0,r5
0001c4  d11d              BNE      |L1.514|
                  |L1.454|
;;;406      {
;;;407        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;408        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;409        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;410        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;411        
;;;412        /* Reset the Output N Polarity level */
;;;413        tmpccer &= CCER_CC2NP_Reset;
0001c6  f64f757f          MOV      r5,#0xff7f
0001ca  402a              ANDS     r2,r2,r5
;;;414        /* Set the Output N Polarity */
;;;415        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
0001cc  894d              LDRH     r5,[r1,#0xa]
0001ce  f64f76ff          MOV      r6,#0xffff
0001d2  ea061505          AND      r5,r6,r5,LSL #4
0001d6  432a              ORRS     r2,r2,r5
;;;416        /* Reset the Output N State */
;;;417        tmpccer &= CCER_CC2NE_Reset;
0001d8  f64f75bf          MOV      r5,#0xffbf
0001dc  402a              ANDS     r2,r2,r5
;;;418        
;;;419        /* Set the Output N State */
;;;420        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
0001de  888d              LDRH     r5,[r1,#4]
0001e0  ea061505          AND      r5,r6,r5,LSL #4
0001e4  432a              ORRS     r2,r2,r5
;;;421        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;422        tmpcr2 &= CR2_OIS2_Reset;
0001e6  f64735ff          MOV      r5,#0x7bff
0001ea  402b              ANDS     r3,r3,r5
;;;423        tmpcr2 &= CR2_OIS2N_Reset;
0001ec  f24775ff          MOV      r5,#0x77ff
0001f0  402b              ANDS     r3,r3,r5
;;;424        /* Set the Output Idle state */
;;;425        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
0001f2  898d              LDRH     r5,[r1,#0xc]
0001f4  ea060585          AND      r5,r6,r5,LSL #2
0001f8  432b              ORRS     r3,r3,r5
;;;426        /* Set the Output N Idle state */
;;;427        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
0001fa  89cd              LDRH     r5,[r1,#0xe]
0001fc  ea060585          AND      r5,r6,r5,LSL #2
000200  432b              ORRS     r3,r3,r5
                  |L1.514|
;;;428      }
;;;429      /* Write to TIMx CR2 */
;;;430      TIMx->CR2 = tmpcr2;
000202  8083              STRH     r3,[r0,#4]
;;;431      
;;;432      /* Write to TIMx CCMR1 */
;;;433      TIMx->CCMR1 = tmpccmrx;
000204  8304              STRH     r4,[r0,#0x18]
;;;434      
;;;435      /* Write to TIMx CCER */
;;;436      TIMx->CCER = tmpccer;
000206  8402              STRH     r2,[r0,#0x20]
;;;437    }
000208  bd70              POP      {r4-r6,pc}
;;;438    
                          ENDP

                  TIM_OC3Init PROC
;;;448      */
;;;449    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00020a  b570              PUSH     {r4-r6,lr}
;;;450    {
;;;451      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
00020c  2400              MOVS     r4,#0
00020e  2200              MOVS     r2,#0
000210  2300              MOVS     r3,#0
;;;452       
;;;453      /* Check the parameters */
;;;454      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;455      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;456      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;457      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;458      /* Disable the Channel 2: Reset the CC2E Bit */
;;;459      TIMx->CCER &= CCER_CC3E_Reset;
000212  8c05              LDRH     r5,[r0,#0x20]
000214  f64f66ff          MOV      r6,#0xfeff
000218  4035              ANDS     r5,r5,r6
00021a  8405              STRH     r5,[r0,#0x20]
;;;460      
;;;461      /* Get the TIMx CCER register value */
;;;462      tmpccer = TIMx->CCER;
00021c  8c02              LDRH     r2,[r0,#0x20]
;;;463      /* Get the TIMx CR2 register value */
;;;464      tmpcr2 =  TIMx->CR2;
00021e  8883              LDRH     r3,[r0,#4]
;;;465      
;;;466      /* Get the TIMx CCMR2 register value */
;;;467      tmpccmrx = TIMx->CCMR2;
000220  8b84              LDRH     r4,[r0,#0x1c]
;;;468        
;;;469      /* Reset the Output Compare Mode Bits */
;;;470      tmpccmrx &= CCMR_OC13M_Mask;
000222  f64f758f          MOV      r5,#0xff8f
000226  402c              ANDS     r4,r4,r5
;;;471      
;;;472      /* Select the Output Compare Mode */
;;;473      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000228  880d              LDRH     r5,[r1,#0]
00022a  432c              ORRS     r4,r4,r5
;;;474      
;;;475      /* Reset the Output Polarity level */
;;;476      tmpccer &= CCER_CC3P_Reset;
00022c  f64f55ff          MOV      r5,#0xfdff
000230  402a              ANDS     r2,r2,r5
;;;477      /* Set the Output Compare Polarity */
;;;478      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000232  890d              LDRH     r5,[r1,#8]
000234  f64f76ff          MOV      r6,#0xffff
000238  ea062505          AND      r5,r6,r5,LSL #8
00023c  432a              ORRS     r2,r2,r5
;;;479      
;;;480      /* Set the Output State */
;;;481      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
00023e  884d              LDRH     r5,[r1,#2]
000240  ea062505          AND      r5,r6,r5,LSL #8
000244  432a              ORRS     r2,r2,r5
;;;482      
;;;483      /* Set the Capture Compare Register value */
;;;484      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000246  88cd              LDRH     r5,[r1,#6]
000248  8785              STRH     r5,[r0,#0x3c]
;;;485      
;;;486      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
00024a  4d68              LDR      r5,|L1.1004|
00024c  42a8              CMP      r0,r5
00024e  d002              BEQ      |L1.598|
000250  4d67              LDR      r5,|L1.1008|
000252  42a8              CMP      r0,r5
000254  d11d              BNE      |L1.658|
                  |L1.598|
;;;487      {
;;;488        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;489        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;490        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;491        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;492        
;;;493        /* Reset the Output N Polarity level */
;;;494        tmpccer &= CCER_CC3NP_Reset;
000256  f24f75ff          MOV      r5,#0xf7ff
00025a  402a              ANDS     r2,r2,r5
;;;495        /* Set the Output N Polarity */
;;;496        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
00025c  894d              LDRH     r5,[r1,#0xa]
00025e  f64f76ff          MOV      r6,#0xffff
000262  ea062505          AND      r5,r6,r5,LSL #8
000266  432a              ORRS     r2,r2,r5
;;;497        /* Reset the Output N State */
;;;498        tmpccer &= CCER_CC3NE_Reset;
000268  f64f35ff          MOV      r5,#0xfbff
00026c  402a              ANDS     r2,r2,r5
;;;499        
;;;500        /* Set the Output N State */
;;;501        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
00026e  888d              LDRH     r5,[r1,#4]
000270  ea062505          AND      r5,r6,r5,LSL #8
000274  432a              ORRS     r2,r2,r5
;;;502        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;503        tmpcr2 &= CR2_OIS3_Reset;
000276  f64675ff          MOV      r5,#0x6fff
00027a  402b              ANDS     r3,r3,r5
;;;504        tmpcr2 &= CR2_OIS3N_Reset;
00027c  f64575ff          MOV      r5,#0x5fff
000280  402b              ANDS     r3,r3,r5
;;;505        /* Set the Output Idle state */
;;;506        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000282  898d              LDRH     r5,[r1,#0xc]
000284  ea061505          AND      r5,r6,r5,LSL #4
000288  432b              ORRS     r3,r3,r5
;;;507        /* Set the Output N Idle state */
;;;508        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
00028a  89cd              LDRH     r5,[r1,#0xe]
00028c  ea061505          AND      r5,r6,r5,LSL #4
000290  432b              ORRS     r3,r3,r5
                  |L1.658|
;;;509      }
;;;510      /* Write to TIMx CR2 */
;;;511      TIMx->CR2 = tmpcr2;
000292  8083              STRH     r3,[r0,#4]
;;;512      
;;;513      /* Write to TIMx CCMR2 */
;;;514      TIMx->CCMR2 = tmpccmrx;
000294  8384              STRH     r4,[r0,#0x1c]
;;;515      
;;;516      /* Write to TIMx CCER */
;;;517      TIMx->CCER = tmpccer;
000296  8402              STRH     r2,[r0,#0x20]
;;;518    }
000298  bd70              POP      {r4-r6,pc}
;;;519    
                          ENDP

                  TIM_OC4Init PROC
;;;529      */
;;;530    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
00029a  b570              PUSH     {r4-r6,lr}
;;;531    {
;;;532      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
00029c  2400              MOVS     r4,#0
00029e  2200              MOVS     r2,#0
0002a0  2300              MOVS     r3,#0
;;;533       
;;;534      /* Check the parameters */
;;;535      assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;536      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;537      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;538      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;539      /* Disable the Channel 2: Reset the CC4E Bit */
;;;540      TIMx->CCER &= CCER_CC4E_Reset;
0002a2  8c05              LDRH     r5,[r0,#0x20]
0002a4  f64e76ff          MOV      r6,#0xefff
0002a8  4035              ANDS     r5,r5,r6
0002aa  8405              STRH     r5,[r0,#0x20]
;;;541      
;;;542      /* Get the TIMx CCER register value */
;;;543      tmpccer = TIMx->CCER;
0002ac  8c02              LDRH     r2,[r0,#0x20]
;;;544      /* Get the TIMx CR2 register value */
;;;545      tmpcr2 =  TIMx->CR2;
0002ae  8883              LDRH     r3,[r0,#4]
;;;546      
;;;547      /* Get the TIMx CCMR2 register value */
;;;548      tmpccmrx = TIMx->CCMR2;
0002b0  8b84              LDRH     r4,[r0,#0x1c]
;;;549        
;;;550      /* Reset the Output Compare Mode Bits */
;;;551      tmpccmrx &= CCMR_OC24M_Mask;
0002b2  f64875ff          MOV      r5,#0x8fff
0002b6  402c              ANDS     r4,r4,r5
;;;552      
;;;553      /* Select the Output Compare Mode */
;;;554      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
0002b8  880d              LDRH     r5,[r1,#0]
0002ba  f64f76ff          MOV      r6,#0xffff
0002be  ea062505          AND      r5,r6,r5,LSL #8
0002c2  432c              ORRS     r4,r4,r5
;;;555      
;;;556      /* Reset the Output Polarity level */
;;;557      tmpccer &= CCER_CC4P_Reset;
0002c4  f64d75ff          MOV      r5,#0xdfff
0002c8  402a              ANDS     r2,r2,r5
;;;558      /* Set the Output Compare Polarity */
;;;559      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
0002ca  890d              LDRH     r5,[r1,#8]
0002cc  ea063505          AND      r5,r6,r5,LSL #12
0002d0  432a              ORRS     r2,r2,r5
;;;560      
;;;561      /* Set the Output State */
;;;562      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
0002d2  884d              LDRH     r5,[r1,#2]
0002d4  ea063505          AND      r5,r6,r5,LSL #12
0002d8  432a              ORRS     r2,r2,r5
;;;563      
;;;564      /* Set the Capture Compare Register value */
;;;565      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
0002da  88cd              LDRH     r5,[r1,#6]
0002dc  f8a05040          STRH     r5,[r0,#0x40]
;;;566      
;;;567      if((*(uint32_t*)&TIMx == TIM1_BASE) || (*(uint32_t*)&TIMx == TIM8_BASE))
0002e0  4d42              LDR      r5,|L1.1004|
0002e2  42a8              CMP      r0,r5
0002e4  d002              BEQ      |L1.748|
0002e6  4d42              LDR      r5,|L1.1008|
0002e8  42a8              CMP      r0,r5
0002ea  d107              BNE      |L1.764|
                  |L1.748|
;;;568      {
;;;569        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;570        /* Reset the Ouput Compare IDLE State */
;;;571        tmpcr2 &= CR2_OIS4_Reset;
0002ec  f3c3030d          UBFX     r3,r3,#0,#14
;;;572        /* Set the Output Idle state */
;;;573        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
0002f0  898d              LDRH     r5,[r1,#0xc]
0002f2  f64f76ff          MOV      r6,#0xffff
0002f6  ea061585          AND      r5,r6,r5,LSL #6
0002fa  432b              ORRS     r3,r3,r5
                  |L1.764|
;;;574      }
;;;575      /* Write to TIMx CR2 */
;;;576      TIMx->CR2 = tmpcr2;
0002fc  8083              STRH     r3,[r0,#4]
;;;577      
;;;578      /* Write to TIMx CCMR2 */  
;;;579      TIMx->CCMR2 = tmpccmrx;
0002fe  8384              STRH     r4,[r0,#0x1c]
;;;580      
;;;581      /* Write to TIMx CCER */
;;;582      TIMx->CCER = tmpccer;
000300  8402              STRH     r2,[r0,#0x20]
;;;583    }
000302  bd70              POP      {r4-r6,pc}
;;;584    
                          ENDP

                  TIM_SetIC4Prescaler PROC
;;;2429     */
;;;2430   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000304  8b82              LDRH     r2,[r0,#0x1c]
;;;2431   {  
;;;2432     /* Check the parameters */
;;;2433     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2434     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2435     /* Reset the IC4PSC Bits */
;;;2436     TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
000306  f24f33ff          MOV      r3,#0xf3ff
00030a  401a              ANDS     r2,r2,r3
00030c  8382              STRH     r2,[r0,#0x1c]
;;;2437     /* Set the IC4PSC value */
;;;2438     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
00030e  8b82              LDRH     r2,[r0,#0x1c]
000310  f64f73ff          MOV      r3,#0xffff
000314  ea032301          AND      r3,r3,r1,LSL #8
000318  431a              ORRS     r2,r2,r3
00031a  8382              STRH     r2,[r0,#0x1c]
;;;2439   }
00031c  4770              BX       lr
;;;2440   
                          ENDP

                  TI4_Config PROC
;;;2815     */
;;;2816   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
00031e  b5f0              PUSH     {r4-r7,lr}
;;;2817                          uint16_t TIM_ICFilter)
;;;2818   {
000320  460c              MOV      r4,r1
000322  4615              MOV      r5,r2
;;;2819     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000324  2100              MOVS     r1,#0
000326  2200              MOVS     r2,#0
000328  2600              MOVS     r6,#0
;;;2820     /* Disable the Channel 4: Reset the CC4E Bit */
;;;2821     TIMx->CCER &= CCER_CC4E_Reset;
00032a  8c07              LDRH     r7,[r0,#0x20]
00032c  f64e7cff          MOV      r12,#0xefff
000330  ea07070c          AND      r7,r7,r12
000334  8407              STRH     r7,[r0,#0x20]
;;;2822     tmpccmr2 = TIMx->CCMR2;
000336  8b81              LDRH     r1,[r0,#0x1c]
;;;2823     tmpccer = TIMx->CCER;
000338  8c02              LDRH     r2,[r0,#0x20]
;;;2824     tmp = (uint16_t)(TIM_ICPolarity << 12);
00033a  f64f77ff          MOV      r7,#0xffff
00033e  ea073604          AND      r6,r7,r4,LSL #12
;;;2825     /* Select the Input and set the filter */
;;;2826     tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000342  f64047ff          MOV      r7,#0xcff
000346  4039              ANDS     r1,r1,r7
;;;2827     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8) | (uint16_t)(TIM_ICFilter << 12);
000348  f64f77ff          MOV      r7,#0xffff
00034c  ea072705          AND      r7,r7,r5,LSL #8
000350  f64f7cff          MOV      r12,#0xffff
000354  ea0c3c03          AND      r12,r12,r3,LSL #12
000358  ea47070c          ORR      r7,r7,r12
00035c  4339              ORRS     r1,r1,r7
;;;2828     /* Select the Polarity and set the CC4E Bit */
;;;2829     tmpccer &= CCER_CC4P_Reset;
00035e  f64d77ff          MOV      r7,#0xdfff
000362  403a              ANDS     r2,r2,r7
;;;2830     tmpccer |= tmp | CCER_CC4E_Set;
000364  f4465780          ORR      r7,r6,#0x1000
000368  433a              ORRS     r2,r2,r7
;;;2831     /* Write to TIMx CCMR2 and CCER registers */
;;;2832     TIMx->CCMR2 = tmpccmr2;
00036a  8381              STRH     r1,[r0,#0x1c]
;;;2833     TIMx->CCER = tmpccer ;
00036c  8402              STRH     r2,[r0,#0x20]
;;;2834   }
00036e  bdf0              POP      {r4-r7,pc}
;;;2835   
                          ENDP

                  TIM_SetIC3Prescaler PROC
;;;2405     */
;;;2406   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000370  8b82              LDRH     r2,[r0,#0x1c]
;;;2407   {
;;;2408     /* Check the parameters */
;;;2409     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2410     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2411     /* Reset the IC3PSC Bits */
;;;2412     TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
000372  f64f73f3          MOV      r3,#0xfff3
000376  401a              ANDS     r2,r2,r3
000378  8382              STRH     r2,[r0,#0x1c]
;;;2413     /* Set the IC3PSC value */
;;;2414     TIMx->CCMR2 |= TIM_ICPSC;
00037a  8b82              LDRH     r2,[r0,#0x1c]
00037c  430a              ORRS     r2,r2,r1
00037e  8382              STRH     r2,[r0,#0x1c]
;;;2415   }
000380  4770              BX       lr
;;;2416   
                          ENDP

                  TI3_Config PROC
;;;2775     */
;;;2776   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000382  b5f0              PUSH     {r4-r7,lr}
;;;2777                          uint16_t TIM_ICFilter)
;;;2778   {
000384  460c              MOV      r4,r1
000386  4615              MOV      r5,r2
;;;2779     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000388  2100              MOVS     r1,#0
00038a  2200              MOVS     r2,#0
00038c  2600              MOVS     r6,#0
;;;2780     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2781     TIMx->CCER &= CCER_CC3E_Reset;
00038e  8c07              LDRH     r7,[r0,#0x20]
000390  f64f6cff          MOV      r12,#0xfeff
000394  ea07070c          AND      r7,r7,r12
000398  8407              STRH     r7,[r0,#0x20]
;;;2782     tmpccmr2 = TIMx->CCMR2;
00039a  8b81              LDRH     r1,[r0,#0x1c]
;;;2783     tmpccer = TIMx->CCER;
00039c  8c02              LDRH     r2,[r0,#0x20]
;;;2784     tmp = (uint16_t)(TIM_ICPolarity << 8);
00039e  f64f77ff          MOV      r7,#0xffff
0003a2  ea072604          AND      r6,r7,r4,LSL #8
;;;2785     /* Select the Input and set the filter */
;;;2786     tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
0003a6  f64f770c          MOV      r7,#0xff0c
0003aa  4039              ANDS     r1,r1,r7
;;;2787     tmpccmr2 |= TIM_ICSelection | (uint16_t)(TIM_ICFilter << 4);
0003ac  f64f77ff          MOV      r7,#0xffff
0003b0  ea071703          AND      r7,r7,r3,LSL #4
0003b4  432f              ORRS     r7,r7,r5
0003b6  4339              ORRS     r1,r1,r7
;;;2788     /* Select the Polarity and set the CC3E Bit */
;;;2789     tmpccer &= CCER_CC3P_Reset;
0003b8  f64f57ff          MOV      r7,#0xfdff
0003bc  403a              ANDS     r2,r2,r7
;;;2790     tmpccer |= tmp | CCER_CC3E_Set;
0003be  f4467780          ORR      r7,r6,#0x100
0003c2  433a              ORRS     r2,r2,r7
;;;2791     /* Write to TIMx CCMR2 and CCER registers */
;;;2792     TIMx->CCMR2 = tmpccmr2;
0003c4  8381              STRH     r1,[r0,#0x1c]
;;;2793     TIMx->CCER = tmpccer;
0003c6  8402              STRH     r2,[r0,#0x20]
;;;2794   }
0003c8  bdf0              POP      {r4-r7,pc}
;;;2795   
                          ENDP

                  TIM_SetIC2Prescaler PROC
;;;2381     */
;;;2382   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
0003ca  8b02              LDRH     r2,[r0,#0x18]
;;;2383   {
;;;2384     /* Check the parameters */
;;;2385     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2386     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2387     /* Reset the IC2PSC Bits */
;;;2388     TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
0003cc  f24f33ff          MOV      r3,#0xf3ff
0003d0  401a              ANDS     r2,r2,r3
0003d2  8302              STRH     r2,[r0,#0x18]
;;;2389     /* Set the IC2PSC value */
;;;2390     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
0003d4  8b02              LDRH     r2,[r0,#0x18]
0003d6  f64f73ff          MOV      r3,#0xffff
0003da  ea032301          AND      r3,r3,r1,LSL #8
0003de  431a              ORRS     r2,r2,r3
0003e0  8302              STRH     r2,[r0,#0x18]
;;;2391   }
0003e2  4770              BX       lr
                  |L1.996|
                          DCD      0x40001000
                  |L1.1000|
                          DCD      0xbffffc00
                  |L1.1004|
                          DCD      0x40012c00
                  |L1.1008|
                          DCD      0x40013400
                          ENDP

                  TI2_Config PROC
;;;2734     */
;;;2735   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
0003f4  b5f0              PUSH     {r4-r7,lr}
;;;2736                          uint16_t TIM_ICFilter)
;;;2737   {
0003f6  460c              MOV      r4,r1
0003f8  4615              MOV      r5,r2
;;;2738     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
0003fa  2100              MOVS     r1,#0
0003fc  2200              MOVS     r2,#0
0003fe  2600              MOVS     r6,#0
;;;2739     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2740     TIMx->CCER &= CCER_CC2E_Reset;
000400  8c07              LDRH     r7,[r0,#0x20]
000402  f64f7cef          MOV      r12,#0xffef
000406  ea07070c          AND      r7,r7,r12
00040a  8407              STRH     r7,[r0,#0x20]
;;;2741     tmpccmr1 = TIMx->CCMR1;
00040c  8b01              LDRH     r1,[r0,#0x18]
;;;2742     tmpccer = TIMx->CCER;
00040e  8c02              LDRH     r2,[r0,#0x20]
;;;2743     tmp = (uint16_t)(TIM_ICPolarity << 4);
000410  f64f77ff          MOV      r7,#0xffff
000414  ea071604          AND      r6,r7,r4,LSL #4
;;;2744     /* Select the Input and set the filter */
;;;2745     tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
000418  f64047ff          MOV      r7,#0xcff
00041c  4039              ANDS     r1,r1,r7
;;;2746     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00041e  f64f77ff          MOV      r7,#0xffff
000422  ea073703          AND      r7,r7,r3,LSL #12
000426  4339              ORRS     r1,r1,r7
;;;2747     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000428  f64f77ff          MOV      r7,#0xffff
00042c  ea072705          AND      r7,r7,r5,LSL #8
000430  4339              ORRS     r1,r1,r7
;;;2748     /* Select the Polarity and set the CC2E Bit */
;;;2749     tmpccer &= CCER_CC2P_Reset;
000432  f64f77df          MOV      r7,#0xffdf
000436  403a              ANDS     r2,r2,r7
;;;2750     tmpccer |=  tmp | CCER_CC2E_Set;
000438  f0460710          ORR      r7,r6,#0x10
00043c  433a              ORRS     r2,r2,r7
;;;2751     /* Write to TIMx CCMR1 and CCER registers */
;;;2752     TIMx->CCMR1 = tmpccmr1 ;
00043e  8301              STRH     r1,[r0,#0x18]
;;;2753     TIMx->CCER = tmpccer;
000440  8402              STRH     r2,[r0,#0x20]
;;;2754   }
000442  bdf0              POP      {r4-r7,pc}
;;;2755   
                          ENDP

                  TIM_SetIC1Prescaler PROC
;;;2357     */
;;;2358   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000444  8b02              LDRH     r2,[r0,#0x18]
;;;2359   {
;;;2360     /* Check the parameters */
;;;2361     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2362     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2363     /* Reset the IC1PSC Bits */
;;;2364     TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
000446  f64f73f3          MOV      r3,#0xfff3
00044a  401a              ANDS     r2,r2,r3
00044c  8302              STRH     r2,[r0,#0x18]
;;;2365     /* Set the IC1PSC value */
;;;2366     TIMx->CCMR1 |= TIM_ICPSC;
00044e  8b02              LDRH     r2,[r0,#0x18]
000450  430a              ORRS     r2,r2,r1
000452  8302              STRH     r2,[r0,#0x18]
;;;2367   }
000454  4770              BX       lr
;;;2368   
                          ENDP

                  TI1_Config PROC
;;;2695     */
;;;2696   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000456  b5f0              PUSH     {r4-r7,lr}
;;;2697                          uint16_t TIM_ICFilter)
;;;2698   {
000458  460c              MOV      r4,r1
00045a  4615              MOV      r5,r2
;;;2699     uint16_t tmpccmr1 = 0, tmpccer = 0;
00045c  2100              MOVS     r1,#0
00045e  2200              MOVS     r2,#0
;;;2700     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2701     TIMx->CCER &= CCER_CC1E_Reset;
000460  8c06              LDRH     r6,[r0,#0x20]
000462  f64f77fe          MOV      r7,#0xfffe
000466  403e              ANDS     r6,r6,r7
000468  8406              STRH     r6,[r0,#0x20]
;;;2702     tmpccmr1 = TIMx->CCMR1;
00046a  8b01              LDRH     r1,[r0,#0x18]
;;;2703     tmpccer = TIMx->CCER;
00046c  8c02              LDRH     r2,[r0,#0x20]
;;;2704     /* Select the Input and set the filter */
;;;2705     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
00046e  f64f760c          MOV      r6,#0xff0c
000472  4031              ANDS     r1,r1,r6
;;;2706     tmpccmr1 |= TIM_ICSelection | (uint16_t)(TIM_ICFilter << 4);
000474  1c7e              ADDS     r6,r7,#1
000476  ea061603          AND      r6,r6,r3,LSL #4
00047a  432e              ORRS     r6,r6,r5
00047c  4331              ORRS     r1,r1,r6
;;;2707     /* Select the Polarity and set the CC1E Bit */
;;;2708     tmpccer &= CCER_CC1P_Reset;
00047e  1e7e              SUBS     r6,r7,#1
000480  4032              ANDS     r2,r2,r6
;;;2709     tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
000482  f0440601          ORR      r6,r4,#1
000486  4332              ORRS     r2,r2,r6
;;;2710     /* Write to TIMx CCMR1 and CCER registers */
;;;2711     TIMx->CCMR1 = tmpccmr1;
000488  8301              STRH     r1,[r0,#0x18]
;;;2712     TIMx->CCER = tmpccer;
00048a  8402              STRH     r2,[r0,#0x20]
;;;2713   }
00048c  bdf0              POP      {r4-r7,pc}
;;;2714   
                          ENDP

                  TIM_ICInit PROC
;;;594      */
;;;595    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
00048e  b570              PUSH     {r4-r6,lr}
;;;596    {
000490  4605              MOV      r5,r0
000492  460c              MOV      r4,r1
;;;597      /* Check the parameters */
;;;598      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;599      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
;;;600      assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;601      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;602      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;603      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;604      
;;;605      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000494  8820              LDRH     r0,[r4,#0]
000496  b950              CBNZ     r0,|L1.1198|
;;;606      {
;;;607        /* TI1 Configuration */
;;;608        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000498  8923              LDRH     r3,[r4,#8]
00049a  88a2              LDRH     r2,[r4,#4]
00049c  8861              LDRH     r1,[r4,#2]
00049e  4628              MOV      r0,r5
0004a0  f7fffffe          BL       TI1_Config
;;;609                   TIM_ICInitStruct->TIM_ICSelection,
;;;610                   TIM_ICInitStruct->TIM_ICFilter);
;;;611        /* Set the Input Capture Prescaler value */
;;;612        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004a4  88e1              LDRH     r1,[r4,#6]
0004a6  4628              MOV      r0,r5
0004a8  f7fffffe          BL       TIM_SetIC1Prescaler
0004ac  e025              B        |L1.1274|
                  |L1.1198|
;;;613      }
;;;614      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
0004ae  8820              LDRH     r0,[r4,#0]
0004b0  2804              CMP      r0,#4
0004b2  d10a              BNE      |L1.1226|
;;;615      {
;;;616        /* TI2 Configuration */
;;;617        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
0004b4  8923              LDRH     r3,[r4,#8]
0004b6  88a2              LDRH     r2,[r4,#4]
0004b8  8861              LDRH     r1,[r4,#2]
0004ba  4628              MOV      r0,r5
0004bc  f7fffffe          BL       TI2_Config
;;;618                   TIM_ICInitStruct->TIM_ICSelection,
;;;619                   TIM_ICInitStruct->TIM_ICFilter);
;;;620        /* Set the Input Capture Prescaler value */
;;;621        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004c0  88e1              LDRH     r1,[r4,#6]
0004c2  4628              MOV      r0,r5
0004c4  f7fffffe          BL       TIM_SetIC2Prescaler
0004c8  e017              B        |L1.1274|
                  |L1.1226|
;;;622      }
;;;623      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
0004ca  8820              LDRH     r0,[r4,#0]
0004cc  2808              CMP      r0,#8
0004ce  d10a              BNE      |L1.1254|
;;;624      {
;;;625        /* TI3 Configuration */
;;;626        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
0004d0  8923              LDRH     r3,[r4,#8]
0004d2  88a2              LDRH     r2,[r4,#4]
0004d4  8861              LDRH     r1,[r4,#2]
0004d6  4628              MOV      r0,r5
0004d8  f7fffffe          BL       TI3_Config
;;;627                   TIM_ICInitStruct->TIM_ICSelection,
;;;628                   TIM_ICInitStruct->TIM_ICFilter);
;;;629        /* Set the Input Capture Prescaler value */
;;;630        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004dc  88e1              LDRH     r1,[r4,#6]
0004de  4628              MOV      r0,r5
0004e0  f7fffffe          BL       TIM_SetIC3Prescaler
0004e4  e009              B        |L1.1274|
                  |L1.1254|
;;;631      }
;;;632      else
;;;633      {
;;;634        /* TI4 Configuration */
;;;635        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
0004e6  8923              LDRH     r3,[r4,#8]
0004e8  88a2              LDRH     r2,[r4,#4]
0004ea  8861              LDRH     r1,[r4,#2]
0004ec  4628              MOV      r0,r5
0004ee  f7fffffe          BL       TI4_Config
;;;636                   TIM_ICInitStruct->TIM_ICSelection,
;;;637                   TIM_ICInitStruct->TIM_ICFilter);
;;;638        /* Set the Input Capture Prescaler value */
;;;639        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
0004f2  88e1              LDRH     r1,[r4,#6]
0004f4  4628              MOV      r0,r5
0004f6  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L1.1274|
;;;640      }
;;;641    }
0004fa  bd70              POP      {r4-r6,pc}
;;;642    
                          ENDP

                  TIM_PWMIConfig PROC
;;;653      */
;;;654    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
0004fc  e92d41f0          PUSH     {r4-r8,lr}
;;;655    {
000500  4605              MOV      r5,r0
000502  460c              MOV      r4,r1
;;;656      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000504  2600              MOVS     r6,#0
;;;657      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
000506  2701              MOVS     r7,#1
;;;658      /* Check the parameters */
;;;659      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;660      /* Select the Opposite Input Polarity */
;;;661      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000508  8860              LDRH     r0,[r4,#2]
00050a  b908              CBNZ     r0,|L1.1296|
;;;662      {
;;;663        icoppositepolarity = TIM_ICPolarity_Falling;
00050c  2602              MOVS     r6,#2
00050e  e000              B        |L1.1298|
                  |L1.1296|
;;;664      }
;;;665      else
;;;666      {
;;;667        icoppositepolarity = TIM_ICPolarity_Rising;
000510  2600              MOVS     r6,#0
                  |L1.1298|
;;;668      }
;;;669      /* Select the Opposite Input */
;;;670      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000512  88a0              LDRH     r0,[r4,#4]
000514  2801              CMP      r0,#1
000516  d101              BNE      |L1.1308|
;;;671      {
;;;672        icoppositeselection = TIM_ICSelection_IndirectTI;
000518  2702              MOVS     r7,#2
00051a  e000              B        |L1.1310|
                  |L1.1308|
;;;673      }
;;;674      else
;;;675      {
;;;676        icoppositeselection = TIM_ICSelection_DirectTI;
00051c  2701              MOVS     r7,#1
                  |L1.1310|
;;;677      }
;;;678      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00051e  8820              LDRH     r0,[r4,#0]
000520  b9a0              CBNZ     r0,|L1.1356|
;;;679      {
;;;680        /* TI1 Configuration */
;;;681        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000522  8923              LDRH     r3,[r4,#8]
000524  88a2              LDRH     r2,[r4,#4]
000526  8861              LDRH     r1,[r4,#2]
000528  4628              MOV      r0,r5
00052a  f7fffffe          BL       TI1_Config
;;;682                   TIM_ICInitStruct->TIM_ICFilter);
;;;683        /* Set the Input Capture Prescaler value */
;;;684        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00052e  88e1              LDRH     r1,[r4,#6]
000530  4628              MOV      r0,r5
000532  f7fffffe          BL       TIM_SetIC1Prescaler
;;;685        /* TI2 Configuration */
;;;686        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000536  8923              LDRH     r3,[r4,#8]
000538  463a              MOV      r2,r7
00053a  4631              MOV      r1,r6
00053c  4628              MOV      r0,r5
00053e  f7fffffe          BL       TI2_Config
;;;687        /* Set the Input Capture Prescaler value */
;;;688        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000542  88e1              LDRH     r1,[r4,#6]
000544  4628              MOV      r0,r5
000546  f7fffffe          BL       TIM_SetIC2Prescaler
00054a  e013              B        |L1.1396|
                  |L1.1356|
;;;689      }
;;;690      else
;;;691      { 
;;;692        /* TI2 Configuration */
;;;693        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00054c  8923              LDRH     r3,[r4,#8]
00054e  88a2              LDRH     r2,[r4,#4]
000550  8861              LDRH     r1,[r4,#2]
000552  4628              MOV      r0,r5
000554  f7fffffe          BL       TI2_Config
;;;694                   TIM_ICInitStruct->TIM_ICFilter);
;;;695        /* Set the Input Capture Prescaler value */
;;;696        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000558  88e1              LDRH     r1,[r4,#6]
00055a  4628              MOV      r0,r5
00055c  f7fffffe          BL       TIM_SetIC2Prescaler
;;;697        /* TI1 Configuration */
;;;698        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000560  8923              LDRH     r3,[r4,#8]
000562  463a              MOV      r2,r7
000564  4631              MOV      r1,r6
000566  4628              MOV      r0,r5
000568  f7fffffe          BL       TI1_Config
;;;699        /* Set the Input Capture Prescaler value */
;;;700        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00056c  88e1              LDRH     r1,[r4,#6]
00056e  4628              MOV      r0,r5
000570  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L1.1396|
;;;701      }
;;;702    }
000574  e8bd81f0          POP      {r4-r8,pc}
;;;703    
                          ENDP

                  TIM_BDTRConfig PROC
;;;712      */
;;;713    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000578  880a              LDRH     r2,[r1,#0]
;;;714    {
;;;715      /* Check the parameters */
;;;716      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;717      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;718      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;719      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;720      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;721      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;722      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;723      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;724         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;725      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
00057a  884b              LDRH     r3,[r1,#2]
00057c  431a              ORRS     r2,r2,r3
00057e  888b              LDRH     r3,[r1,#4]
000580  431a              ORRS     r2,r2,r3
000582  88cb              LDRH     r3,[r1,#6]
000584  431a              ORRS     r2,r2,r3
000586  890b              LDRH     r3,[r1,#8]
000588  431a              ORRS     r2,r2,r3
00058a  894b              LDRH     r3,[r1,#0xa]
00058c  431a              ORRS     r2,r2,r3
00058e  898b              LDRH     r3,[r1,#0xc]
000590  431a              ORRS     r2,r2,r3
000592  f8a02044          STRH     r2,[r0,#0x44]
;;;726                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;727                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;728                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;729    }
000596  4770              BX       lr
;;;730    
                          ENDP

                  TIM_TimeBaseStructInit PROC
;;;736      */
;;;737    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000598  f64f71ff          MOV      r1,#0xffff
;;;738    {
;;;739      /* Set the default configuration */
;;;740      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
00059c  8081              STRH     r1,[r0,#4]
;;;741      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
00059e  2100              MOVS     r1,#0
0005a0  8001              STRH     r1,[r0,#0]
;;;742      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
0005a2  80c1              STRH     r1,[r0,#6]
;;;743      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
0005a4  8041              STRH     r1,[r0,#2]
;;;744      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
0005a6  7201              STRB     r1,[r0,#8]
;;;745    }
0005a8  4770              BX       lr
;;;746    
                          ENDP

                  TIM_OCStructInit PROC
;;;752      */
;;;753    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
0005aa  2100              MOVS     r1,#0
;;;754    {
;;;755      /* Set the default configuration */
;;;756      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
0005ac  8001              STRH     r1,[r0,#0]
;;;757      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
0005ae  8041              STRH     r1,[r0,#2]
;;;758      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
0005b0  8081              STRH     r1,[r0,#4]
;;;759      TIM_OCInitStruct->TIM_Pulse = 0x0000;
0005b2  80c1              STRH     r1,[r0,#6]
;;;760      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
0005b4  8101              STRH     r1,[r0,#8]
;;;761      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
0005b6  8141              STRH     r1,[r0,#0xa]
;;;762      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
0005b8  8181              STRH     r1,[r0,#0xc]
;;;763      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
0005ba  81c1              STRH     r1,[r0,#0xe]
;;;764    }
0005bc  4770              BX       lr
;;;765    
                          ENDP

                  TIM_ICStructInit PROC
;;;771      */
;;;772    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
0005be  2100              MOVS     r1,#0
;;;773    {
;;;774      /* Set the default configuration */
;;;775      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
0005c0  8001              STRH     r1,[r0,#0]
;;;776      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
0005c2  8041              STRH     r1,[r0,#2]
;;;777      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
0005c4  2101              MOVS     r1,#1
0005c6  8081              STRH     r1,[r0,#4]
;;;778      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
0005c8  2100              MOVS     r1,#0
0005ca  80c1              STRH     r1,[r0,#6]
;;;779      TIM_ICInitStruct->TIM_ICFilter = 0x00;
0005cc  8101              STRH     r1,[r0,#8]
;;;780    }
0005ce  4770              BX       lr
;;;781    
                          ENDP

                  TIM_BDTRStructInit PROC
;;;787      */
;;;788    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
0005d0  2100              MOVS     r1,#0
;;;789    {
;;;790      /* Set the default configuration */
;;;791      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
0005d2  8001              STRH     r1,[r0,#0]
;;;792      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
0005d4  8041              STRH     r1,[r0,#2]
;;;793      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
0005d6  8081              STRH     r1,[r0,#4]
;;;794      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
0005d8  80c1              STRH     r1,[r0,#6]
;;;795      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
0005da  8101              STRH     r1,[r0,#8]
;;;796      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
0005dc  8141              STRH     r1,[r0,#0xa]
;;;797      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
0005de  8181              STRH     r1,[r0,#0xc]
;;;798    }
0005e0  4770              BX       lr
;;;799    
                          ENDP

                  TIM_Cmd PROC
;;;806      */
;;;807    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
0005e2  b121              CBZ      r1,|L1.1518|
;;;808    {
;;;809      /* Check the parameters */
;;;810      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;811      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;812      
;;;813      if (NewState != DISABLE)
;;;814      {
;;;815        /* Enable the TIM Counter */
;;;816        TIMx->CR1 |= CR1_CEN_Set;
0005e4  8802              LDRH     r2,[r0,#0]
0005e6  f0420201          ORR      r2,r2,#1
0005ea  8002              STRH     r2,[r0,#0]
0005ec  e004              B        |L1.1528|
                  |L1.1518|
;;;817      }
;;;818      else
;;;819      {
;;;820        /* Disable the TIM Counter */
;;;821        TIMx->CR1 &= CR1_CEN_Reset;
0005ee  8802              LDRH     r2,[r0,#0]
0005f0  f24033fe          MOV      r3,#0x3fe
0005f4  401a              ANDS     r2,r2,r3
0005f6  8002              STRH     r2,[r0,#0]
                  |L1.1528|
;;;822      }
;;;823    }
0005f8  4770              BX       lr
;;;824    
                          ENDP

                  TIM_CtrlPWMOutputs PROC
;;;831      */
;;;832    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
0005fa  b131              CBZ      r1,|L1.1546|
;;;833    {
;;;834      /* Check the parameters */
;;;835      assert_param(IS_TIM_18_PERIPH(TIMx));
;;;836      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;837      if (NewState != DISABLE)
;;;838      {
;;;839        /* Enable the TIM Main Output */
;;;840        TIMx->BDTR |= BDTR_MOE_Set;
0005fc  f8b02044          LDRH     r2,[r0,#0x44]
000600  f4424200          ORR      r2,r2,#0x8000
000604  f8a02044          STRH     r2,[r0,#0x44]
000608  e005              B        |L1.1558|
                  |L1.1546|
;;;841      }
;;;842      else
;;;843      {
;;;844        /* Disable the TIM Main Output */
;;;845        TIMx->BDTR &= BDTR_MOE_Reset;
00060a  f8b02044          LDRH     r2,[r0,#0x44]
00060e  f3c2020e          UBFX     r2,r2,#0,#15
000612  f8a02044          STRH     r2,[r0,#0x44]
                  |L1.1558|
;;;846      }  
;;;847    }
000616  4770              BX       lr
;;;848    
                          ENDP

                  TIM_ITConfig PROC
;;;866      */
;;;867    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000618  b11a              CBZ      r2,|L1.1570|
;;;868    {  
;;;869      /* Check the parameters */
;;;870      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;871      assert_param(IS_TIM_IT(TIM_IT));
;;;872      assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
;;;873      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;874      
;;;875      if (NewState != DISABLE)
;;;876      {
;;;877        /* Enable the Interrupt sources */
;;;878        TIMx->DIER |= TIM_IT;
00061a  8983              LDRH     r3,[r0,#0xc]
00061c  430b              ORRS     r3,r3,r1
00061e  8183              STRH     r3,[r0,#0xc]
000620  e002              B        |L1.1576|
                  |L1.1570|
;;;879      }
;;;880      else
;;;881      {
;;;882        /* Disable the Interrupt sources */
;;;883        TIMx->DIER &= (uint16_t)~TIM_IT;
000622  8983              LDRH     r3,[r0,#0xc]
000624  438b              BICS     r3,r3,r1
000626  8183              STRH     r3,[r0,#0xc]
                  |L1.1576|
;;;884      }
;;;885    }
000628  4770              BX       lr
;;;886    
                          ENDP

                  TIM_GenerateEvent PROC
;;;899      */
;;;900    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
00062a  8281              STRH     r1,[r0,#0x14]
;;;901    { 
;;;902      /* Check the parameters */
;;;903      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;904      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;905      assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
;;;906      /* Set the event sources */
;;;907      TIMx->EGR = TIM_EventSource;
;;;908    }
00062c  4770              BX       lr
;;;909    
                          ENDP

                  TIM_DMAConfig PROC
;;;927      */
;;;928    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
00062e  ea410302          ORR      r3,r1,r2
;;;929    {
;;;930      /* Check the parameters */
;;;931      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;932      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;933      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;934      /* Set the DMA Base and the DMA Burst Length */
;;;935      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000632  f8a03048          STRH     r3,[r0,#0x48]
;;;936    }
000636  4770              BX       lr
;;;937    
                          ENDP

                  TIM_DMACmd PROC
;;;953      */
;;;954    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000638  b11a              CBZ      r2,|L1.1602|
;;;955    { 
;;;956      /* Check the parameters */
;;;957      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;958      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;959      assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
;;;960      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;961      
;;;962      if (NewState != DISABLE)
;;;963      {
;;;964        /* Enable the DMA sources */
;;;965        TIMx->DIER |= TIM_DMASource; 
00063a  8983              LDRH     r3,[r0,#0xc]
00063c  430b              ORRS     r3,r3,r1
00063e  8183              STRH     r3,[r0,#0xc]
000640  e002              B        |L1.1608|
                  |L1.1602|
;;;966      }
;;;967      else
;;;968      {
;;;969        /* Disable the DMA sources */
;;;970        TIMx->DIER &= (uint16_t)~TIM_DMASource;
000642  8983              LDRH     r3,[r0,#0xc]
000644  438b              BICS     r3,r3,r1
000646  8183              STRH     r3,[r0,#0xc]
                  |L1.1608|
;;;971      }
;;;972    }
000648  4770              BX       lr
;;;973    
                          ENDP

                  TIM_InternalClockConfig PROC
;;;979      */
;;;980    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
00064a  8901              LDRH     r1,[r0,#8]
;;;981    {
;;;982      /* Check the parameters */
;;;983      assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;984      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;985      TIMx->SMCR &=  SMCR_SMS_Mask;
00064c  f64f72f8          MOV      r2,#0xfff8
000650  4011              ANDS     r1,r1,r2
000652  8101              STRH     r1,[r0,#8]
;;;986    }
000654  4770              BX       lr
;;;987    
                          ENDP

                  TIM_SelectInputTrigger PROC
;;;1228     */
;;;1229   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000656  460a              MOV      r2,r1
;;;1230   {
;;;1231     uint16_t tmpsmcr = 0;
000658  2100              MOVS     r1,#0
;;;1232     /* Check the parameters */
;;;1233     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1234     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1235     /* Get the TIMx SMCR register value */
;;;1236     tmpsmcr = TIMx->SMCR;
00065a  8901              LDRH     r1,[r0,#8]
;;;1237     /* Reset the TS Bits */
;;;1238     tmpsmcr &= SMCR_TS_Mask;
00065c  f64f738f          MOV      r3,#0xff8f
000660  4019              ANDS     r1,r1,r3
;;;1239     /* Set the Input Trigger source */
;;;1240     tmpsmcr |= TIM_InputTriggerSource;
000662  4311              ORRS     r1,r1,r2
;;;1241     /* Write to TIMx SMCR */
;;;1242     TIMx->SMCR = tmpsmcr;
000664  8101              STRH     r1,[r0,#8]
;;;1243   }
000666  4770              BX       lr
;;;1244   
                          ENDP

                  TIM_ITRxExternalClockConfig PROC
;;;999      */
;;;1000   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000668  b530              PUSH     {r4,r5,lr}
;;;1001   {
00066a  4604              MOV      r4,r0
00066c  460d              MOV      r5,r1
;;;1002     /* Check the parameters */
;;;1003     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1004     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1005     /* Select the Internal Trigger */
;;;1006     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
00066e  4629              MOV      r1,r5
000670  4620              MOV      r0,r4
000672  f7fffffe          BL       TIM_SelectInputTrigger
;;;1007     /* Select the External clock mode1 */
;;;1008     TIMx->SMCR |= TIM_SlaveMode_External1;
000676  8920              LDRH     r0,[r4,#8]
000678  f0400007          ORR      r0,r0,#7
00067c  8120              STRH     r0,[r4,#8]
;;;1009   }
00067e  bd30              POP      {r4,r5,pc}
;;;1010   
                          ENDP

                  TIM_TIxExternalClockConfig PROC
;;;1027     */
;;;1028   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000680  e92d41f0          PUSH     {r4-r8,lr}
;;;1029                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1030   {
000684  4604              MOV      r4,r0
000686  460d              MOV      r5,r1
000688  4616              MOV      r6,r2
00068a  461f              MOV      r7,r3
;;;1031     /* Check the parameters */
;;;1032     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1033     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1034     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1035     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1036     /* Configure the Timer Input Clock Source */
;;;1037     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00068c  2d60              CMP      r5,#0x60
00068e  d106              BNE      |L1.1694|
;;;1038     {
;;;1039       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
000690  463b              MOV      r3,r7
000692  2201              MOVS     r2,#1
000694  4631              MOV      r1,r6
000696  4620              MOV      r0,r4
000698  f7fffffe          BL       TI2_Config
00069c  e005              B        |L1.1706|
                  |L1.1694|
;;;1040     }
;;;1041     else
;;;1042     {
;;;1043       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00069e  463b              MOV      r3,r7
0006a0  2201              MOVS     r2,#1
0006a2  4631              MOV      r1,r6
0006a4  4620              MOV      r0,r4
0006a6  f7fffffe          BL       TI1_Config
                  |L1.1706|
;;;1044     }
;;;1045     /* Select the Trigger source */
;;;1046     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
0006aa  4629              MOV      r1,r5
0006ac  4620              MOV      r0,r4
0006ae  f7fffffe          BL       TIM_SelectInputTrigger
;;;1047     /* Select the External clock mode1 */
;;;1048     TIMx->SMCR |= TIM_SlaveMode_External1;
0006b2  8920              LDRH     r0,[r4,#8]
0006b4  f0400007          ORR      r0,r0,#7
0006b8  8120              STRH     r0,[r4,#8]
;;;1049   }
0006ba  e8bd81f0          POP      {r4-r8,pc}
;;;1050   
                          ENDP

                  TIM_ETRConfig PROC
;;;1143     */
;;;1144   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
0006be  b570              PUSH     {r4-r6,lr}
;;;1145                      uint16_t ExtTRGFilter)
;;;1146   {
0006c0  460c              MOV      r4,r1
;;;1147     uint16_t tmpsmcr = 0;
0006c2  2100              MOVS     r1,#0
;;;1148     /* Check the parameters */
;;;1149     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1150     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1151     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1152     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1153     tmpsmcr = TIMx->SMCR;
0006c4  8901              LDRH     r1,[r0,#8]
;;;1154     /* Reset the ETR Bits */
;;;1155     tmpsmcr &= SMCR_ETR_Mask;
0006c6  b2c9              UXTB     r1,r1
;;;1156     /* Set the Prescaler, the Filter value and the Polarity */
;;;1157     tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << 8);
0006c8  ea440502          ORR      r5,r4,r2
0006cc  f64f76ff          MOV      r6,#0xffff
0006d0  ea062603          AND      r6,r6,r3,LSL #8
0006d4  4335              ORRS     r5,r5,r6
0006d6  4329              ORRS     r1,r1,r5
;;;1158     /* Write to TIMx SMCR */
;;;1159     TIMx->SMCR = tmpsmcr;
0006d8  8101              STRH     r1,[r0,#8]
;;;1160   }
0006da  bd70              POP      {r4-r6,pc}
;;;1161   
                          ENDP

                  TIM_ETRClockMode1Config PROC
;;;1068     */
;;;1069   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
0006dc  e92d41f0          PUSH     {r4-r8,lr}
;;;1070                                uint16_t ExtTRGFilter)
;;;1071   {
0006e0  4605              MOV      r5,r0
0006e2  460e              MOV      r6,r1
0006e4  4617              MOV      r7,r2
0006e6  4698              MOV      r8,r3
;;;1072     uint16_t tmpsmcr = 0;
0006e8  2400              MOVS     r4,#0
;;;1073     /* Check the parameters */
;;;1074     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1075     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1076     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1077     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1078     /* Configure the ETR Clock source */
;;;1079     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
0006ea  4643              MOV      r3,r8
0006ec  463a              MOV      r2,r7
0006ee  4631              MOV      r1,r6
0006f0  4628              MOV      r0,r5
0006f2  f7fffffe          BL       TIM_ETRConfig
;;;1080     
;;;1081     /* Get the TIMx SMCR register value */
;;;1082     tmpsmcr = TIMx->SMCR;
0006f6  892c              LDRH     r4,[r5,#8]
;;;1083     /* Reset the SMS Bits */
;;;1084     tmpsmcr &= SMCR_SMS_Mask;
0006f8  f64f70f8          MOV      r0,#0xfff8
0006fc  4004              ANDS     r4,r4,r0
;;;1085     /* Select the External clock mode1 */
;;;1086     tmpsmcr |= TIM_SlaveMode_External1;
0006fe  f0440407          ORR      r4,r4,#7
;;;1087     /* Select the Trigger selection : ETRF */
;;;1088     tmpsmcr &= SMCR_TS_Mask;
000702  f64f708f          MOV      r0,#0xff8f
000706  4004              ANDS     r4,r4,r0
;;;1089     tmpsmcr |= TIM_TS_ETRF;
000708  f0440470          ORR      r4,r4,#0x70
;;;1090     /* Write to TIMx SMCR */
;;;1091     TIMx->SMCR = tmpsmcr;
00070c  812c              STRH     r4,[r5,#8]
;;;1092   }
00070e  e8bd81f0          POP      {r4-r8,pc}
;;;1093   
                          ENDP

                  TIM_ETRClockMode2Config PROC
;;;1111     */
;;;1112   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000712  b5f0              PUSH     {r4-r7,lr}
;;;1113                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1114   {
000714  4604              MOV      r4,r0
000716  460d              MOV      r5,r1
000718  4616              MOV      r6,r2
00071a  461f              MOV      r7,r3
;;;1115     /* Check the parameters */
;;;1116     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1117     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1118     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1119     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1120     /* Configure the ETR Clock source */
;;;1121     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00071c  463b              MOV      r3,r7
00071e  4632              MOV      r2,r6
000720  4629              MOV      r1,r5
000722  4620              MOV      r0,r4
000724  f7fffffe          BL       TIM_ETRConfig
;;;1122     /* Enable the External clock mode2 */
;;;1123     TIMx->SMCR |= SMCR_ECE_Set;
000728  8920              LDRH     r0,[r4,#8]
00072a  f4404080          ORR      r0,r0,#0x4000
00072e  8120              STRH     r0,[r4,#8]
;;;1124   }
000730  bdf0              POP      {r4-r7,pc}
;;;1125   
                          ENDP

                  TIM_PrescalerConfig PROC
;;;1173     */
;;;1174   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000732  8501              STRH     r1,[r0,#0x28]
;;;1175   {
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1178     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1179     /* Set the Prescaler value */
;;;1180     TIMx->PSC = Prescaler;
;;;1181     /* Set or reset the UG Bit */
;;;1182     TIMx->EGR = TIM_PSCReloadMode;
000734  8282              STRH     r2,[r0,#0x14]
;;;1183   }
000736  4770              BX       lr
;;;1184   
                          ENDP

                  TIM_CounterModeConfig PROC
;;;1197     */
;;;1198   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000738  460a              MOV      r2,r1
;;;1199   {
;;;1200     uint16_t tmpcr1 = 0;
00073a  2100              MOVS     r1,#0
;;;1201     /* Check the parameters */
;;;1202     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1203     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1204     tmpcr1 = TIMx->CR1;
00073c  8801              LDRH     r1,[r0,#0]
;;;1205     /* Reset the CMS and DIR Bits */
;;;1206     tmpcr1 &= CR1_CounterMode_Mask;
00073e  f240338f          MOV      r3,#0x38f
000742  4019              ANDS     r1,r1,r3
;;;1207     /* Set the Counter Mode */
;;;1208     tmpcr1 |= TIM_CounterMode;
000744  4311              ORRS     r1,r1,r2
;;;1209     /* Write to TIMx CR1 register */
;;;1210     TIMx->CR1 = tmpcr1;
000746  8001              STRH     r1,[r0,#0]
;;;1211   }
000748  4770              BX       lr
;;;1212   
                          ENDP

                  TIM_EncoderInterfaceConfig PROC
;;;1266     */
;;;1267   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
00074a  b5f0              PUSH     {r4-r7,lr}
;;;1268                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1269   {
00074c  460c              MOV      r4,r1
00074e  4615              MOV      r5,r2
000750  461e              MOV      r6,r3
;;;1270     uint16_t tmpsmcr = 0;
000752  2100              MOVS     r1,#0
;;;1271     uint16_t tmpccmr1 = 0;
000754  2200              MOVS     r2,#0
;;;1272     uint16_t tmpccer = 0;
000756  2300              MOVS     r3,#0
;;;1273       
;;;1274     /* Check the parameters */
;;;1275     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1276     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1277     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1278     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1279     /* Get the TIMx SMCR register value */
;;;1280     tmpsmcr = TIMx->SMCR;
000758  8901              LDRH     r1,[r0,#8]
;;;1281     /* Get the TIMx CCMR1 register value */
;;;1282     tmpccmr1 = TIMx->CCMR1;
00075a  8b02              LDRH     r2,[r0,#0x18]
;;;1283     /* Get the TIMx CCER register value */
;;;1284     tmpccer = TIMx->CCER;
00075c  8c03              LDRH     r3,[r0,#0x20]
;;;1285     /* Set the encoder Mode */
;;;1286     tmpsmcr &= SMCR_SMS_Mask;
00075e  f64f77f8          MOV      r7,#0xfff8
000762  4039              ANDS     r1,r1,r7
;;;1287     tmpsmcr |= TIM_EncoderMode;
000764  4321              ORRS     r1,r1,r4
;;;1288     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1289     tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
000766  f64f47fc          MOV      r7,#0xfcfc
00076a  403a              ANDS     r2,r2,r7
;;;1290     tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
00076c  f2401701          MOV      r7,#0x101
000770  433a              ORRS     r2,r2,r7
;;;1291     /* Set the TI1 and the TI2 Polarities */
;;;1292     tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
000772  f64f77dd          MOV      r7,#0xffdd
000776  403b              ANDS     r3,r3,r7
;;;1293     tmpccer |= (TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << 4));
000778  f64f77ff          MOV      r7,#0xffff
00077c  ea071706          AND      r7,r7,r6,LSL #4
000780  432f              ORRS     r7,r7,r5
000782  433b              ORRS     r3,r3,r7
;;;1294     /* Write to TIMx SMCR */
;;;1295     TIMx->SMCR = tmpsmcr;
000784  8101              STRH     r1,[r0,#8]
;;;1296     /* Write to TIMx CCMR1 */
;;;1297     TIMx->CCMR1 = tmpccmr1;
000786  8302              STRH     r2,[r0,#0x18]
;;;1298     /* Write to TIMx CCER */
;;;1299     TIMx->CCER = tmpccer;
000788  8403              STRH     r3,[r0,#0x20]
;;;1300   }
00078a  bdf0              POP      {r4-r7,pc}
;;;1301   
                          ENDP

                  TIM_ForcedOC1Config PROC
;;;1313     */
;;;1314   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
00078c  460a              MOV      r2,r1
;;;1315   {
;;;1316     uint16_t tmpccmr1 = 0;
00078e  2100              MOVS     r1,#0
;;;1317     /* Check the parameters */
;;;1318     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1319     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1320     tmpccmr1 = TIMx->CCMR1;
000790  8b01              LDRH     r1,[r0,#0x18]
;;;1321     /* Reset the OC1M Bits */
;;;1322     tmpccmr1 &= CCMR_OC13M_Mask;
000792  f64f738f          MOV      r3,#0xff8f
000796  4019              ANDS     r1,r1,r3
;;;1323     /* Configure The Forced output Mode */
;;;1324     tmpccmr1 |= TIM_ForcedAction;
000798  4311              ORRS     r1,r1,r2
;;;1325     /* Write to TIMx CCMR1 register */
;;;1326     TIMx->CCMR1 = tmpccmr1;
00079a  8301              STRH     r1,[r0,#0x18]
;;;1327   }
00079c  4770              BX       lr
;;;1328   
                          ENDP

                  TIM_ForcedOC2Config PROC
;;;1340     */
;;;1341   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
00079e  460a              MOV      r2,r1
;;;1342   {
;;;1343     uint16_t tmpccmr1 = 0;
0007a0  2100              MOVS     r1,#0
;;;1344     /* Check the parameters */
;;;1345     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1346     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1347     tmpccmr1 = TIMx->CCMR1;
0007a2  8b01              LDRH     r1,[r0,#0x18]
;;;1348     /* Reset the OC2M Bits */
;;;1349     tmpccmr1 &= CCMR_OC24M_Mask;
0007a4  f64873ff          MOV      r3,#0x8fff
0007a8  4019              ANDS     r1,r1,r3
;;;1350     /* Configure The Forced output Mode */
;;;1351     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
0007aa  f64f73ff          MOV      r3,#0xffff
0007ae  ea032302          AND      r3,r3,r2,LSL #8
0007b2  4319              ORRS     r1,r1,r3
;;;1352     /* Write to TIMx CCMR1 register */
;;;1353     TIMx->CCMR1 = tmpccmr1;
0007b4  8301              STRH     r1,[r0,#0x18]
;;;1354   }
0007b6  4770              BX       lr
;;;1355   
                          ENDP

                  TIM_ForcedOC3Config PROC
;;;1367     */
;;;1368   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
0007b8  460a              MOV      r2,r1
;;;1369   {
;;;1370     uint16_t tmpccmr2 = 0;
0007ba  2100              MOVS     r1,#0
;;;1371     /* Check the parameters */
;;;1372     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1373     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1374     tmpccmr2 = TIMx->CCMR2;
0007bc  8b81              LDRH     r1,[r0,#0x1c]
;;;1375     /* Reset the OC1M Bits */
;;;1376     tmpccmr2 &= CCMR_OC13M_Mask;
0007be  f64f738f          MOV      r3,#0xff8f
0007c2  4019              ANDS     r1,r1,r3
;;;1377     /* Configure The Forced output Mode */
;;;1378     tmpccmr2 |= TIM_ForcedAction;
0007c4  4311              ORRS     r1,r1,r2
;;;1379     /* Write to TIMx CCMR2 register */
;;;1380     TIMx->CCMR2 = tmpccmr2;
0007c6  8381              STRH     r1,[r0,#0x1c]
;;;1381   }
0007c8  4770              BX       lr
;;;1382   
                          ENDP

                  TIM_ForcedOC4Config PROC
;;;1394     */
;;;1395   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
0007ca  460a              MOV      r2,r1
;;;1396   {
;;;1397     uint16_t tmpccmr2 = 0;
0007cc  2100              MOVS     r1,#0
;;;1398     /* Check the parameters */
;;;1399     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1400     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1401     tmpccmr2 = TIMx->CCMR2;
0007ce  8b81              LDRH     r1,[r0,#0x1c]
;;;1402     /* Reset the OC2M Bits */
;;;1403     tmpccmr2 &= CCMR_OC24M_Mask;
0007d0  f64873ff          MOV      r3,#0x8fff
0007d4  4019              ANDS     r1,r1,r3
;;;1404     /* Configure The Forced output Mode */
;;;1405     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
0007d6  f64f73ff          MOV      r3,#0xffff
0007da  ea032302          AND      r3,r3,r2,LSL #8
0007de  4319              ORRS     r1,r1,r3
;;;1406     /* Write to TIMx CCMR2 register */
;;;1407     TIMx->CCMR2 = tmpccmr2;
0007e0  8381              STRH     r1,[r0,#0x1c]
;;;1408   }
0007e2  4770              BX       lr
;;;1409   
                          ENDP

                  TIM_ARRPreloadConfig PROC
;;;1417     */
;;;1418   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
0007e4  b121              CBZ      r1,|L1.2032|
;;;1419   {
;;;1420     /* Check the parameters */
;;;1421     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1422     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1423     if (NewState != DISABLE)
;;;1424     {
;;;1425       /* Set the ARR Preload Bit */
;;;1426       TIMx->CR1 |= CR1_ARPE_Set;
0007e6  8802              LDRH     r2,[r0,#0]
0007e8  f0420280          ORR      r2,r2,#0x80
0007ec  8002              STRH     r2,[r0,#0]
0007ee  e004              B        |L1.2042|
                  |L1.2032|
;;;1427     }
;;;1428     else
;;;1429     {
;;;1430       /* Reset the ARR Preload Bit */
;;;1431       TIMx->CR1 &= CR1_ARPE_Reset;
0007f0  8802              LDRH     r2,[r0,#0]
0007f2  f240337f          MOV      r3,#0x37f
0007f6  401a              ANDS     r2,r2,r3
0007f8  8002              STRH     r2,[r0,#0]
                  |L1.2042|
;;;1432     }
;;;1433   }
0007fa  4770              BX       lr
;;;1434   
                          ENDP

                  TIM_SelectCOM PROC
;;;1441     */
;;;1442   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
0007fc  b121              CBZ      r1,|L1.2056|
;;;1443   {
;;;1444     /* Check the parameters */
;;;1445     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1446     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1447     if (NewState != DISABLE)
;;;1448     {
;;;1449       /* Set the COM Bit */
;;;1450       TIMx->CR2 |= CR2_CCUS_Set;
0007fe  8882              LDRH     r2,[r0,#4]
000800  f0420204          ORR      r2,r2,#4
000804  8082              STRH     r2,[r0,#4]
000806  e004              B        |L1.2066|
                  |L1.2056|
;;;1451     }
;;;1452     else
;;;1453     {
;;;1454       /* Reset the COM Bit */
;;;1455       TIMx->CR2 &= CR2_CCUS_Reset;
000808  8882              LDRH     r2,[r0,#4]
00080a  f64f73fb          MOV      r3,#0xfffb
00080e  401a              ANDS     r2,r2,r3
000810  8082              STRH     r2,[r0,#4]
                  |L1.2066|
;;;1456     }
;;;1457   }
000812  4770              BX       lr
;;;1458   
                          ENDP

                  TIM_SelectCCDMA PROC
;;;1466     */
;;;1467   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000814  b121              CBZ      r1,|L1.2080|
;;;1468   {
;;;1469     /* Check the parameters */
;;;1470     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1471     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1472     if (NewState != DISABLE)
;;;1473     {
;;;1474       /* Set the CCDS Bit */
;;;1475       TIMx->CR2 |= CR2_CCDS_Set;
000816  8882              LDRH     r2,[r0,#4]
000818  f0420208          ORR      r2,r2,#8
00081c  8082              STRH     r2,[r0,#4]
00081e  e004              B        |L1.2090|
                  |L1.2080|
;;;1476     }
;;;1477     else
;;;1478     {
;;;1479       /* Reset the CCDS Bit */
;;;1480       TIMx->CR2 &= CR2_CCDS_Reset;
000820  8882              LDRH     r2,[r0,#4]
000822  f64f73f7          MOV      r3,#0xfff7
000826  401a              ANDS     r2,r2,r3
000828  8082              STRH     r2,[r0,#4]
                  |L1.2090|
;;;1481     }
;;;1482   }
00082a  4770              BX       lr
;;;1483   
                          ENDP

                  TIM_CCPreloadControl PROC
;;;1491     */
;;;1492   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
00082c  b121              CBZ      r1,|L1.2104|
;;;1493   { 
;;;1494     /* Check the parameters */
;;;1495     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1496     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1497     if (NewState != DISABLE)
;;;1498     {
;;;1499       /* Set the CCPC Bit */
;;;1500       TIMx->CR2 |= CR2_CCPC_Set;
00082e  8882              LDRH     r2,[r0,#4]
000830  f0420201          ORR      r2,r2,#1
000834  8082              STRH     r2,[r0,#4]
000836  e004              B        |L1.2114|
                  |L1.2104|
;;;1501     }
;;;1502     else
;;;1503     {
;;;1504       /* Reset the CCPC Bit */
;;;1505       TIMx->CR2 &= CR2_CCPC_Reset;
000838  8882              LDRH     r2,[r0,#4]
00083a  f64f73fe          MOV      r3,#0xfffe
00083e  401a              ANDS     r2,r2,r3
000840  8082              STRH     r2,[r0,#4]
                  |L1.2114|
;;;1506     }
;;;1507   }
000842  4770              BX       lr
;;;1508   
                          ENDP

                  TIM_OC1PreloadConfig PROC
;;;1519     */
;;;1520   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000844  460a              MOV      r2,r1
;;;1521   {
;;;1522     uint16_t tmpccmr1 = 0;
000846  2100              MOVS     r1,#0
;;;1523     /* Check the parameters */
;;;1524     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1525     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1526     tmpccmr1 = TIMx->CCMR1;
000848  8b01              LDRH     r1,[r0,#0x18]
;;;1527     /* Reset the OC1PE Bit */
;;;1528     tmpccmr1 &= CCMR_OC13PE_Reset;
00084a  f64f73f7          MOV      r3,#0xfff7
00084e  4019              ANDS     r1,r1,r3
;;;1529     /* Enable or Disable the Output Compare Preload feature */
;;;1530     tmpccmr1 |= TIM_OCPreload;
000850  4311              ORRS     r1,r1,r2
;;;1531     /* Write to TIMx CCMR1 register */
;;;1532     TIMx->CCMR1 = tmpccmr1;
000852  8301              STRH     r1,[r0,#0x18]
;;;1533   }
000854  4770              BX       lr
;;;1534   
                          ENDP

                  TIM_OC2PreloadConfig PROC
;;;1545     */
;;;1546   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000856  460a              MOV      r2,r1
;;;1547   {
;;;1548     uint16_t tmpccmr1 = 0;
000858  2100              MOVS     r1,#0
;;;1549     /* Check the parameters */
;;;1550     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1551     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1552     tmpccmr1 = TIMx->CCMR1;
00085a  8b01              LDRH     r1,[r0,#0x18]
;;;1553     /* Reset the OC2PE Bit */
;;;1554     tmpccmr1 &= CCMR_OC24PE_Reset;
00085c  f24f73ff          MOV      r3,#0xf7ff
000860  4019              ANDS     r1,r1,r3
;;;1555     /* Enable or Disable the Output Compare Preload feature */
;;;1556     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000862  f64f73ff          MOV      r3,#0xffff
000866  ea032302          AND      r3,r3,r2,LSL #8
00086a  4319              ORRS     r1,r1,r3
;;;1557     /* Write to TIMx CCMR1 register */
;;;1558     TIMx->CCMR1 = tmpccmr1;
00086c  8301              STRH     r1,[r0,#0x18]
;;;1559   }
00086e  4770              BX       lr
;;;1560   
                          ENDP

                  TIM_OC3PreloadConfig PROC
;;;1571     */
;;;1572   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000870  460a              MOV      r2,r1
;;;1573   {
;;;1574     uint16_t tmpccmr2 = 0;
000872  2100              MOVS     r1,#0
;;;1575     /* Check the parameters */
;;;1576     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1577     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1578     tmpccmr2 = TIMx->CCMR2;
000874  8b81              LDRH     r1,[r0,#0x1c]
;;;1579     /* Reset the OC3PE Bit */
;;;1580     tmpccmr2 &= CCMR_OC13PE_Reset;
000876  f64f73f7          MOV      r3,#0xfff7
00087a  4019              ANDS     r1,r1,r3
;;;1581     /* Enable or Disable the Output Compare Preload feature */
;;;1582     tmpccmr2 |= TIM_OCPreload;
00087c  4311              ORRS     r1,r1,r2
;;;1583     /* Write to TIMx CCMR2 register */
;;;1584     TIMx->CCMR2 = tmpccmr2;
00087e  8381              STRH     r1,[r0,#0x1c]
;;;1585   }
000880  4770              BX       lr
;;;1586   
                          ENDP

                  TIM_OC4PreloadConfig PROC
;;;1597     */
;;;1598   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000882  460a              MOV      r2,r1
;;;1599   {
;;;1600     uint16_t tmpccmr2 = 0;
000884  2100              MOVS     r1,#0
;;;1601     /* Check the parameters */
;;;1602     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1603     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1604     tmpccmr2 = TIMx->CCMR2;
000886  8b81              LDRH     r1,[r0,#0x1c]
;;;1605     /* Reset the OC4PE Bit */
;;;1606     tmpccmr2 &= CCMR_OC24PE_Reset;
000888  f24f73ff          MOV      r3,#0xf7ff
00088c  4019              ANDS     r1,r1,r3
;;;1607     /* Enable or Disable the Output Compare Preload feature */
;;;1608     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00088e  f64f73ff          MOV      r3,#0xffff
000892  ea032302          AND      r3,r3,r2,LSL #8
000896  4319              ORRS     r1,r1,r3
;;;1609     /* Write to TIMx CCMR2 register */
;;;1610     TIMx->CCMR2 = tmpccmr2;
000898  8381              STRH     r1,[r0,#0x1c]
;;;1611   }
00089a  4770              BX       lr
;;;1612   
                          ENDP

                  TIM_OC1FastConfig PROC
;;;1622     */
;;;1623   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
00089c  460a              MOV      r2,r1
;;;1624   {
;;;1625     uint16_t tmpccmr1 = 0;
00089e  2100              MOVS     r1,#0
;;;1626     /* Check the parameters */
;;;1627     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1628     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1629     /* Get the TIMx CCMR1 register value */
;;;1630     tmpccmr1 = TIMx->CCMR1;
0008a0  8b01              LDRH     r1,[r0,#0x18]
;;;1631     /* Reset the OC1FE Bit */
;;;1632     tmpccmr1 &= CCMR_OC13FE_Reset;
0008a2  f64f73fb          MOV      r3,#0xfffb
0008a6  4019              ANDS     r1,r1,r3
;;;1633     /* Enable or Disable the Output Compare Fast Bit */
;;;1634     tmpccmr1 |= TIM_OCFast;
0008a8  4311              ORRS     r1,r1,r2
;;;1635     /* Write to TIMx CCMR1 */
;;;1636     TIMx->CCMR1 = tmpccmr1;
0008aa  8301              STRH     r1,[r0,#0x18]
;;;1637   }
0008ac  4770              BX       lr
;;;1638   
                          ENDP

                  TIM_OC2FastConfig PROC
;;;1648     */
;;;1649   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0008ae  460a              MOV      r2,r1
;;;1650   {
;;;1651     uint16_t tmpccmr1 = 0;
0008b0  2100              MOVS     r1,#0
;;;1652     /* Check the parameters */
;;;1653     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1654     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1655     /* Get the TIMx CCMR1 register value */
;;;1656     tmpccmr1 = TIMx->CCMR1;
0008b2  8b01              LDRH     r1,[r0,#0x18]
;;;1657     /* Reset the OC2FE Bit */
;;;1658     tmpccmr1 &= CCMR_OC24FE_Reset;
0008b4  f64f33ff          MOV      r3,#0xfbff
0008b8  4019              ANDS     r1,r1,r3
;;;1659     /* Enable or Disable the Output Compare Fast Bit */
;;;1660     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
0008ba  f64f73ff          MOV      r3,#0xffff
0008be  ea032302          AND      r3,r3,r2,LSL #8
0008c2  4319              ORRS     r1,r1,r3
;;;1661     /* Write to TIMx CCMR1 */
;;;1662     TIMx->CCMR1 = tmpccmr1;
0008c4  8301              STRH     r1,[r0,#0x18]
;;;1663   }
0008c6  4770              BX       lr
;;;1664   
                          ENDP

                  TIM_OC3FastConfig PROC
;;;1674     */
;;;1675   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0008c8  460a              MOV      r2,r1
;;;1676   {
;;;1677     uint16_t tmpccmr2 = 0;
0008ca  2100              MOVS     r1,#0
;;;1678     /* Check the parameters */
;;;1679     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1680     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1681     /* Get the TIMx CCMR2 register value */
;;;1682     tmpccmr2 = TIMx->CCMR2;
0008cc  8b81              LDRH     r1,[r0,#0x1c]
;;;1683     /* Reset the OC3FE Bit */
;;;1684     tmpccmr2 &= CCMR_OC13FE_Reset;
0008ce  f64f73fb          MOV      r3,#0xfffb
0008d2  4019              ANDS     r1,r1,r3
;;;1685     /* Enable or Disable the Output Compare Fast Bit */
;;;1686     tmpccmr2 |= TIM_OCFast;
0008d4  4311              ORRS     r1,r1,r2
;;;1687     /* Write to TIMx CCMR2 */
;;;1688     TIMx->CCMR2 = tmpccmr2;
0008d6  8381              STRH     r1,[r0,#0x1c]
;;;1689   }
0008d8  4770              BX       lr
;;;1690   
                          ENDP

                  TIM_OC4FastConfig PROC
;;;1700     */
;;;1701   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
0008da  460a              MOV      r2,r1
;;;1702   {
;;;1703     uint16_t tmpccmr2 = 0;
0008dc  2100              MOVS     r1,#0
;;;1704     /* Check the parameters */
;;;1705     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1706     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1707     /* Get the TIMx CCMR2 register value */
;;;1708     tmpccmr2 = TIMx->CCMR2;
0008de  8b81              LDRH     r1,[r0,#0x1c]
;;;1709     /* Reset the OC4FE Bit */
;;;1710     tmpccmr2 &= CCMR_OC24FE_Reset;
0008e0  f64f33ff          MOV      r3,#0xfbff
0008e4  4019              ANDS     r1,r1,r3
;;;1711     /* Enable or Disable the Output Compare Fast Bit */
;;;1712     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
0008e6  f64f73ff          MOV      r3,#0xffff
0008ea  ea032302          AND      r3,r3,r2,LSL #8
0008ee  4319              ORRS     r1,r1,r3
;;;1713     /* Write to TIMx CCMR2 */
;;;1714     TIMx->CCMR2 = tmpccmr2;
0008f0  8381              STRH     r1,[r0,#0x1c]
;;;1715   }
0008f2  4770              BX       lr
;;;1716   
                          ENDP

                  TIM_ClearOC1Ref PROC
;;;1726     */
;;;1727   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
0008f4  460a              MOV      r2,r1
;;;1728   {
;;;1729     uint16_t tmpccmr1 = 0;
0008f6  2100              MOVS     r1,#0
;;;1730     /* Check the parameters */
;;;1731     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1732     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1733     tmpccmr1 = TIMx->CCMR1;
0008f8  8b01              LDRH     r1,[r0,#0x18]
;;;1734     /* Reset the OC1CE Bit */
;;;1735     tmpccmr1 &= CCMR_OC13CE_Reset;
0008fa  f64f737f          MOV      r3,#0xff7f
0008fe  4019              ANDS     r1,r1,r3
;;;1736     /* Enable or Disable the Output Compare Clear Bit */
;;;1737     tmpccmr1 |= TIM_OCClear;
000900  4311              ORRS     r1,r1,r2
;;;1738     /* Write to TIMx CCMR1 register */
;;;1739     TIMx->CCMR1 = tmpccmr1;
000902  8301              STRH     r1,[r0,#0x18]
;;;1740   }
000904  4770              BX       lr
;;;1741   
                          ENDP

                  TIM_ClearOC2Ref PROC
;;;1751     */
;;;1752   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000906  460a              MOV      r2,r1
;;;1753   {
;;;1754     uint16_t tmpccmr1 = 0;
000908  2100              MOVS     r1,#0
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1757     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1758     tmpccmr1 = TIMx->CCMR1;
00090a  8b01              LDRH     r1,[r0,#0x18]
;;;1759     /* Reset the OC2CE Bit */
;;;1760     tmpccmr1 &= CCMR_OC24CE_Reset;
00090c  f3c1010e          UBFX     r1,r1,#0,#15
;;;1761     /* Enable or Disable the Output Compare Clear Bit */
;;;1762     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000910  f64f73ff          MOV      r3,#0xffff
000914  ea032302          AND      r3,r3,r2,LSL #8
000918  4319              ORRS     r1,r1,r3
;;;1763     /* Write to TIMx CCMR1 register */
;;;1764     TIMx->CCMR1 = tmpccmr1;
00091a  8301              STRH     r1,[r0,#0x18]
;;;1765   }
00091c  4770              BX       lr
;;;1766   
                          ENDP

                  TIM_ClearOC3Ref PROC
;;;1776     */
;;;1777   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
00091e  460a              MOV      r2,r1
;;;1778   {
;;;1779     uint16_t tmpccmr2 = 0;
000920  2100              MOVS     r1,#0
;;;1780     /* Check the parameters */
;;;1781     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1782     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1783     tmpccmr2 = TIMx->CCMR2;
000922  8b81              LDRH     r1,[r0,#0x1c]
;;;1784     /* Reset the OC3CE Bit */
;;;1785     tmpccmr2 &= CCMR_OC13CE_Reset;
000924  f64f737f          MOV      r3,#0xff7f
000928  4019              ANDS     r1,r1,r3
;;;1786     /* Enable or Disable the Output Compare Clear Bit */
;;;1787     tmpccmr2 |= TIM_OCClear;
00092a  4311              ORRS     r1,r1,r2
;;;1788     /* Write to TIMx CCMR2 register */
;;;1789     TIMx->CCMR2 = tmpccmr2;
00092c  8381              STRH     r1,[r0,#0x1c]
;;;1790   }
00092e  4770              BX       lr
;;;1791   
                          ENDP

                  TIM_ClearOC4Ref PROC
;;;1801     */
;;;1802   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000930  460a              MOV      r2,r1
;;;1803   {
;;;1804     uint16_t tmpccmr2 = 0;
000932  2100              MOVS     r1,#0
;;;1805     /* Check the parameters */
;;;1806     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1807     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1808     tmpccmr2 = TIMx->CCMR2;
000934  8b81              LDRH     r1,[r0,#0x1c]
;;;1809     /* Reset the OC4CE Bit */
;;;1810     tmpccmr2 &= CCMR_OC24CE_Reset;
000936  f3c1010e          UBFX     r1,r1,#0,#15
;;;1811     /* Enable or Disable the Output Compare Clear Bit */
;;;1812     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
00093a  f64f73ff          MOV      r3,#0xffff
00093e  ea032302          AND      r3,r3,r2,LSL #8
000942  4319              ORRS     r1,r1,r3
;;;1813     /* Write to TIMx CCMR2 register */
;;;1814     TIMx->CCMR2 = tmpccmr2;
000944  8381              STRH     r1,[r0,#0x1c]
;;;1815   }
000946  4770              BX       lr
;;;1816   
                          ENDP

                  TIM_OC1PolarityConfig PROC
;;;1826     */
;;;1827   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000948  460a              MOV      r2,r1
;;;1828   {
;;;1829     uint16_t tmpccer = 0;
00094a  2100              MOVS     r1,#0
;;;1830     /* Check the parameters */
;;;1831     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1832     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1833     tmpccer = TIMx->CCER;
00094c  8c01              LDRH     r1,[r0,#0x20]
;;;1834     /* Set or Reset the CC1P Bit */
;;;1835     tmpccer &= CCER_CC1P_Reset;
00094e  f64f73fd          MOV      r3,#0xfffd
000952  4019              ANDS     r1,r1,r3
;;;1836     tmpccer |= TIM_OCPolarity;
000954  4311              ORRS     r1,r1,r2
;;;1837     /* Write to TIMx CCER register */
;;;1838     TIMx->CCER = tmpccer;
000956  8401              STRH     r1,[r0,#0x20]
;;;1839   }
000958  4770              BX       lr
;;;1840   
                          ENDP

                  TIM_OC1NPolarityConfig PROC
;;;1849     */
;;;1850   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
00095a  460a              MOV      r2,r1
;;;1851   {
;;;1852     uint16_t tmpccer = 0;
00095c  2100              MOVS     r1,#0
;;;1853     /* Check the parameters */
;;;1854     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1855     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1856      
;;;1857     tmpccer = TIMx->CCER;
00095e  8c01              LDRH     r1,[r0,#0x20]
;;;1858     /* Set or Reset the CC1NP Bit */
;;;1859     tmpccer &= CCER_CC1NP_Reset;
000960  f64f73f7          MOV      r3,#0xfff7
000964  4019              ANDS     r1,r1,r3
;;;1860     tmpccer |= TIM_OCNPolarity;
000966  4311              ORRS     r1,r1,r2
;;;1861     /* Write to TIMx CCER register */
;;;1862     TIMx->CCER = tmpccer;
000968  8401              STRH     r1,[r0,#0x20]
;;;1863   }
00096a  4770              BX       lr
;;;1864   
                          ENDP

                  TIM_OC2PolarityConfig PROC
;;;1874     */
;;;1875   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
00096c  460a              MOV      r2,r1
;;;1876   {
;;;1877     uint16_t tmpccer = 0;
00096e  2100              MOVS     r1,#0
;;;1878     /* Check the parameters */
;;;1879     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1880     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1881     tmpccer = TIMx->CCER;
000970  8c01              LDRH     r1,[r0,#0x20]
;;;1882     /* Set or Reset the CC2P Bit */
;;;1883     tmpccer &= CCER_CC2P_Reset;
000972  f64f73df          MOV      r3,#0xffdf
000976  4019              ANDS     r1,r1,r3
;;;1884     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000978  f64f73ff          MOV      r3,#0xffff
00097c  ea031302          AND      r3,r3,r2,LSL #4
000980  4319              ORRS     r1,r1,r3
;;;1885     /* Write to TIMx CCER register */
;;;1886     TIMx->CCER = tmpccer;
000982  8401              STRH     r1,[r0,#0x20]
;;;1887   }
000984  4770              BX       lr
;;;1888   
                          ENDP

                  TIM_OC2NPolarityConfig PROC
;;;1897     */
;;;1898   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000986  460a              MOV      r2,r1
;;;1899   {
;;;1900     uint16_t tmpccer = 0;
000988  2100              MOVS     r1,#0
;;;1901     /* Check the parameters */
;;;1902     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1903     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1904     
;;;1905     tmpccer = TIMx->CCER;
00098a  8c01              LDRH     r1,[r0,#0x20]
;;;1906     /* Set or Reset the CC2NP Bit */
;;;1907     tmpccer &= CCER_CC2NP_Reset;
00098c  f64f737f          MOV      r3,#0xff7f
000990  4019              ANDS     r1,r1,r3
;;;1908     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000992  f64f73ff          MOV      r3,#0xffff
000996  ea031302          AND      r3,r3,r2,LSL #4
00099a  4319              ORRS     r1,r1,r3
;;;1909     /* Write to TIMx CCER register */
;;;1910     TIMx->CCER = tmpccer;
00099c  8401              STRH     r1,[r0,#0x20]
;;;1911   }
00099e  4770              BX       lr
;;;1912   
                          ENDP

                  TIM_OC3PolarityConfig PROC
;;;1922     */
;;;1923   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0009a0  460a              MOV      r2,r1
;;;1924   {
;;;1925     uint16_t tmpccer = 0;
0009a2  2100              MOVS     r1,#0
;;;1926     /* Check the parameters */
;;;1927     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1928     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1929     tmpccer = TIMx->CCER;
0009a4  8c01              LDRH     r1,[r0,#0x20]
;;;1930     /* Set or Reset the CC3P Bit */
;;;1931     tmpccer &= CCER_CC3P_Reset;
0009a6  f64f53ff          MOV      r3,#0xfdff
0009aa  4019              ANDS     r1,r1,r3
;;;1932     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
0009ac  f64f73ff          MOV      r3,#0xffff
0009b0  ea032302          AND      r3,r3,r2,LSL #8
0009b4  4319              ORRS     r1,r1,r3
;;;1933     /* Write to TIMx CCER register */
;;;1934     TIMx->CCER = tmpccer;
0009b6  8401              STRH     r1,[r0,#0x20]
;;;1935   }
0009b8  4770              BX       lr
;;;1936   
                          ENDP

                  TIM_OC3NPolarityConfig PROC
;;;1945     */
;;;1946   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
0009ba  460a              MOV      r2,r1
;;;1947   {
;;;1948     uint16_t tmpccer = 0;
0009bc  2100              MOVS     r1,#0
;;;1949    
;;;1950     /* Check the parameters */
;;;1951     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;1952     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1953       
;;;1954     tmpccer = TIMx->CCER;
0009be  8c01              LDRH     r1,[r0,#0x20]
;;;1955     /* Set or Reset the CC3NP Bit */
;;;1956     tmpccer &= CCER_CC3NP_Reset;
0009c0  f24f73ff          MOV      r3,#0xf7ff
0009c4  4019              ANDS     r1,r1,r3
;;;1957     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
0009c6  f64f73ff          MOV      r3,#0xffff
0009ca  ea032302          AND      r3,r3,r2,LSL #8
0009ce  4319              ORRS     r1,r1,r3
;;;1958     /* Write to TIMx CCER register */
;;;1959     TIMx->CCER = tmpccer;
0009d0  8401              STRH     r1,[r0,#0x20]
;;;1960   }
0009d2  4770              BX       lr
;;;1961   
                          ENDP

                  TIM_OC4PolarityConfig PROC
;;;1971     */
;;;1972   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
0009d4  460a              MOV      r2,r1
;;;1973   {
;;;1974     uint16_t tmpccer = 0;
0009d6  2100              MOVS     r1,#0
;;;1975     /* Check the parameters */
;;;1976     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;1977     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1978     tmpccer = TIMx->CCER;
0009d8  8c01              LDRH     r1,[r0,#0x20]
;;;1979     /* Set or Reset the CC4P Bit */
;;;1980     tmpccer &= CCER_CC4P_Reset;
0009da  f64d73ff          MOV      r3,#0xdfff
0009de  4019              ANDS     r1,r1,r3
;;;1981     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
0009e0  f64f73ff          MOV      r3,#0xffff
0009e4  ea033302          AND      r3,r3,r2,LSL #12
0009e8  4319              ORRS     r1,r1,r3
;;;1982     /* Write to TIMx CCER register */
;;;1983     TIMx->CCER = tmpccer;
0009ea  8401              STRH     r1,[r0,#0x20]
;;;1984   }
0009ec  4770              BX       lr
;;;1985   
                          ENDP

                  TIM_CCxCmd PROC
;;;1999     */
;;;2000   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
0009ee  b510              PUSH     {r4,lr}
;;;2001   {
;;;2002     /* Check the parameters */
;;;2003     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2004     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2005     assert_param(IS_TIM_CCX(TIM_CCx));
;;;2006     /* Reset the CCxE Bit */
;;;2007     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCE_Set << TIM_Channel)));
0009f0  8c03              LDRH     r3,[r0,#0x20]
0009f2  2401              MOVS     r4,#1
0009f4  408c              LSLS     r4,r4,r1
0009f6  43a3              BICS     r3,r3,r4
0009f8  8403              STRH     r3,[r0,#0x20]
;;;2008     /* Set or reset the CCxE Bit */ 
;;;2009     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
0009fa  8c03              LDRH     r3,[r0,#0x20]
0009fc  fa02f401          LSL      r4,r2,r1
000a00  b2a4              UXTH     r4,r4
000a02  4323              ORRS     r3,r3,r4
000a04  8403              STRH     r3,[r0,#0x20]
;;;2010   }
000a06  bd10              POP      {r4,pc}
;;;2011   
                          ENDP

                  TIM_CCxNCmd PROC
;;;2023     */
;;;2024   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000a08  b510              PUSH     {r4,lr}
;;;2025   {
;;;2026     /* Check the parameters */
;;;2027     assert_param(IS_TIM_18_PERIPH(TIMx));
;;;2028     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2029     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2030     /* Reset the CCxNE Bit */
;;;2031     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCNE_Set << TIM_Channel)));
000a0a  8c03              LDRH     r3,[r0,#0x20]
000a0c  2404              MOVS     r4,#4
000a0e  408c              LSLS     r4,r4,r1
000a10  43a3              BICS     r3,r3,r4
000a12  8403              STRH     r3,[r0,#0x20]
;;;2032     /* Set or reset the CCxNE Bit */ 
;;;2033     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000a14  8c03              LDRH     r3,[r0,#0x20]
000a16  fa02f401          LSL      r4,r2,r1
000a1a  b2a4              UXTH     r4,r4
000a1c  4323              ORRS     r3,r3,r4
000a1e  8403              STRH     r3,[r0,#0x20]
;;;2034   }
000a20  bd10              POP      {r4,pc}
;;;2035   
                          ENDP

                  TIM_SelectOCxM PROC
;;;2059     */
;;;2060   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000a22  b530              PUSH     {r4,r5,lr}
;;;2061   {
;;;2062     /* Check the parameters */
;;;2063     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2064     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2065     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2066     
;;;2067     /* Disable the Channel: Reset the CCxE Bit */
;;;2068     TIMx->CCER &= (uint16_t)(~((uint16_t)(CCER_CCE_Set << TIM_Channel)));
000a24  8c03              LDRH     r3,[r0,#0x20]
000a26  2401              MOVS     r4,#1
000a28  408c              LSLS     r4,r4,r1
000a2a  43a3              BICS     r3,r3,r4
000a2c  8403              STRH     r3,[r0,#0x20]
;;;2069     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000a2e  b109              CBZ      r1,|L1.2612|
000a30  2908              CMP      r1,#8
000a32  d118              BNE      |L1.2662|
                  |L1.2612|
;;;2070     {
;;;2071       /* Reset the OCxM bits in the CCMRx register */
;;;2072       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
000a34  f1000318          ADD      r3,r0,#0x18
000a38  eb030361          ADD      r3,r3,r1,ASR #1
000a3c  681b              LDR      r3,[r3,#0]
000a3e  f64f748f          MOV      r4,#0xff8f
000a42  4023              ANDS     r3,r3,r4
000a44  f1000418          ADD      r4,r0,#0x18
000a48  eb040461          ADD      r4,r4,r1,ASR #1
000a4c  6023              STR      r3,[r4,#0]
;;;2073      
;;;2074       /* Configure the OCxM bits in the CCMRx register */
;;;2075       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) |= TIM_OCMode;
000a4e  f1000318          ADD      r3,r0,#0x18
000a52  eb030361          ADD      r3,r3,r1,ASR #1
000a56  681b              LDR      r3,[r3,#0]
000a58  4313              ORRS     r3,r3,r2
000a5a  f1000418          ADD      r4,r0,#0x18
000a5e  eb040461          ADD      r4,r4,r1,ASR #1
000a62  6023              STR      r3,[r4,#0]
000a64  e01f              B        |L1.2726|
                  |L1.2662|
;;;2076     }
;;;2077     else
;;;2078     {
;;;2079       /* Reset the OCxM bits in the CCMRx register */
;;;2080       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + ((uint16_t)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
000a66  1f0b              SUBS     r3,r1,#4
000a68  f3c3044e          UBFX     r4,r3,#1,#15
000a6c  f1000318          ADD      r3,r0,#0x18
000a70  591b              LDR      r3,[r3,r4]
000a72  f64874ff          MOV      r4,#0x8fff
000a76  4023              ANDS     r3,r3,r4
000a78  1f0c              SUBS     r4,r1,#4
000a7a  f3c4054e          UBFX     r5,r4,#1,#15
000a7e  f1000418          ADD      r4,r0,#0x18
000a82  5163              STR      r3,[r4,r5]
;;;2081       
;;;2082       /* Configure the OCxM bits in the CCMRx register */
;;;2083       *((__IO uint32_t *)((*(uint32_t*)&TIMx) + CCMR_Offset + ((uint16_t)(TIM_Channel - 4)>> 1))) |= (uint16_t)(TIM_OCMode << 8);
000a84  1f0b              SUBS     r3,r1,#4
000a86  f3c3044e          UBFX     r4,r3,#1,#15
000a8a  f1000318          ADD      r3,r0,#0x18
000a8e  591b              LDR      r3,[r3,r4]
000a90  f64f74ff          MOV      r4,#0xffff
000a94  ea042402          AND      r4,r4,r2,LSL #8
000a98  4323              ORRS     r3,r3,r4
000a9a  1f0c              SUBS     r4,r1,#4
000a9c  f3c4054e          UBFX     r5,r4,#1,#15
000aa0  f1000418          ADD      r4,r0,#0x18
000aa4  5163              STR      r3,[r4,r5]
                  |L1.2726|
;;;2084     }
;;;2085   }
000aa6  bd30              POP      {r4,r5,pc}
;;;2086   
                          ENDP

                  TIM_UpdateDisableConfig PROC
;;;2093     */
;;;2094   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000aa8  b121              CBZ      r1,|L1.2740|
;;;2095   {
;;;2096     /* Check the parameters */
;;;2097     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2098     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2099     if (NewState != DISABLE)
;;;2100     {
;;;2101       /* Set the Update Disable Bit */
;;;2102       TIMx->CR1 |= CR1_UDIS_Set;
000aaa  8802              LDRH     r2,[r0,#0]
000aac  f0420202          ORR      r2,r2,#2
000ab0  8002              STRH     r2,[r0,#0]
000ab2  e004              B        |L1.2750|
                  |L1.2740|
;;;2103     }
;;;2104     else
;;;2105     {
;;;2106       /* Reset the Update Disable Bit */
;;;2107       TIMx->CR1 &= CR1_UDIS_Reset;
000ab4  8802              LDRH     r2,[r0,#0]
000ab6  f24033fd          MOV      r3,#0x3fd
000aba  401a              ANDS     r2,r2,r3
000abc  8002              STRH     r2,[r0,#0]
                  |L1.2750|
;;;2108     }
;;;2109   }
000abe  4770              BX       lr
;;;2110   
                          ENDP

                  TIM_UpdateRequestConfig PROC
;;;2119     */
;;;2120   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000ac0  b121              CBZ      r1,|L1.2764|
;;;2121   {
;;;2122     /* Check the parameters */
;;;2123     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2124     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2125     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2126     {
;;;2127       /* Set the URS Bit */
;;;2128       TIMx->CR1 |= CR1_URS_Set;
000ac2  8802              LDRH     r2,[r0,#0]
000ac4  f0420204          ORR      r2,r2,#4
000ac8  8002              STRH     r2,[r0,#0]
000aca  e004              B        |L1.2774|
                  |L1.2764|
;;;2129     }
;;;2130     else
;;;2131     {
;;;2132       /* Reset the URS Bit */
;;;2133       TIMx->CR1 &= CR1_URS_Reset;
000acc  8802              LDRH     r2,[r0,#0]
000ace  f24033fb          MOV      r3,#0x3fb
000ad2  401a              ANDS     r2,r2,r3
000ad4  8002              STRH     r2,[r0,#0]
                  |L1.2774|
;;;2134     }
;;;2135   }
000ad6  4770              BX       lr
;;;2136   
                          ENDP

                  TIM_SelectHallSensor PROC
;;;2143     */
;;;2144   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000ad8  b121              CBZ      r1,|L1.2788|
;;;2145   {
;;;2146     /* Check the parameters */
;;;2147     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2148     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2149     if (NewState != DISABLE)
;;;2150     {
;;;2151       /* Set the TI1S Bit */
;;;2152       TIMx->CR2 |= CR2_TI1S_Set;
000ada  8882              LDRH     r2,[r0,#4]
000adc  f0420280          ORR      r2,r2,#0x80
000ae0  8082              STRH     r2,[r0,#4]
000ae2  e004              B        |L1.2798|
                  |L1.2788|
;;;2153     }
;;;2154     else
;;;2155     {
;;;2156       /* Reset the TI1S Bit */
;;;2157       TIMx->CR2 &= CR2_TI1S_Reset;
000ae4  8882              LDRH     r2,[r0,#4]
000ae6  f64f737f          MOV      r3,#0xff7f
000aea  401a              ANDS     r2,r2,r3
000aec  8082              STRH     r2,[r0,#4]
                  |L1.2798|
;;;2158     }
;;;2159   }
000aee  4770              BX       lr
;;;2160   
                          ENDP

                  TIM_SelectOnePulseMode PROC
;;;2169     */
;;;2170   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000af0  8802              LDRH     r2,[r0,#0]
;;;2171   {
;;;2172     /* Check the parameters */
;;;2173     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2174     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2175     /* Reset the OPM Bit */
;;;2176     TIMx->CR1 &= CR1_OPM_Reset;
000af2  f24033f7          MOV      r3,#0x3f7
000af6  401a              ANDS     r2,r2,r3
000af8  8002              STRH     r2,[r0,#0]
;;;2177     /* Configure the OPM Mode */
;;;2178     TIMx->CR1 |= TIM_OPMode;
000afa  8802              LDRH     r2,[r0,#0]
000afc  430a              ORRS     r2,r2,r1
000afe  8002              STRH     r2,[r0,#0]
;;;2179   }
000b00  4770              BX       lr
;;;2180   
                          ENDP

                  TIM_SelectOutputTrigger PROC
;;;2198     */
;;;2199   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000b02  8882              LDRH     r2,[r0,#4]
;;;2200   {
;;;2201     /* Check the parameters */
;;;2202     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2203     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2204     assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
;;;2205     /* Reset the MMS Bits */
;;;2206     TIMx->CR2 &= CR2_MMS_Mask;
000b04  f64f738f          MOV      r3,#0xff8f
000b08  401a              ANDS     r2,r2,r3
000b0a  8082              STRH     r2,[r0,#4]
;;;2207     /* Select the TRGO source */
;;;2208     TIMx->CR2 |=  TIM_TRGOSource;
000b0c  8882              LDRH     r2,[r0,#4]
000b0e  430a              ORRS     r2,r2,r1
000b10  8082              STRH     r2,[r0,#4]
;;;2209   }
000b12  4770              BX       lr
;;;2210   
                          ENDP

                  TIM_SelectSlaveMode PROC
;;;2222     */
;;;2223   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000b14  8902              LDRH     r2,[r0,#8]
;;;2224   {
;;;2225     /* Check the parameters */
;;;2226     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2227     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2228     /* Reset the SMS Bits */
;;;2229     TIMx->SMCR &= SMCR_SMS_Mask;
000b16  f64f73f8          MOV      r3,#0xfff8
000b1a  401a              ANDS     r2,r2,r3
000b1c  8102              STRH     r2,[r0,#8]
;;;2230     /* Select the Slave Mode */
;;;2231     TIMx->SMCR |= TIM_SlaveMode;
000b1e  8902              LDRH     r2,[r0,#8]
000b20  430a              ORRS     r2,r2,r1
000b22  8102              STRH     r2,[r0,#8]
;;;2232   }
000b24  4770              BX       lr
;;;2233   
                          ENDP

                  TIM_SelectMasterSlaveMode PROC
;;;2244     */
;;;2245   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000b26  8902              LDRH     r2,[r0,#8]
;;;2246   {
;;;2247     /* Check the parameters */
;;;2248     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2249     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2250     /* Reset the MSM Bit */
;;;2251     TIMx->SMCR &= SMCR_MSM_Reset;
000b28  f64f737f          MOV      r3,#0xff7f
000b2c  401a              ANDS     r2,r2,r3
000b2e  8102              STRH     r2,[r0,#8]
;;;2252     
;;;2253     /* Set or Reset the MSM Bit */
;;;2254     TIMx->SMCR |= TIM_MasterSlaveMode;
000b30  8902              LDRH     r2,[r0,#8]
000b32  430a              ORRS     r2,r2,r1
000b34  8102              STRH     r2,[r0,#8]
;;;2255   }
000b36  4770              BX       lr
;;;2256   
                          ENDP

                  TIM_SetCounter PROC
;;;2262     */
;;;2263   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000b38  8481              STRH     r1,[r0,#0x24]
;;;2264   {
;;;2265     /* Check the parameters */
;;;2266     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2267     /* Set the Counter Register value */
;;;2268     TIMx->CNT = Counter;
;;;2269   }
000b3a  4770              BX       lr
;;;2270   
                          ENDP

                  TIM_SetAutoreload PROC
;;;2276     */
;;;2277   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000b3c  8581              STRH     r1,[r0,#0x2c]
;;;2278   {
;;;2279     /* Check the parameters */
;;;2280     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2281     /* Set the Autoreload Register value */
;;;2282     TIMx->ARR = Autoreload;
;;;2283   }
000b3e  4770              BX       lr
;;;2284   
                          ENDP

                  TIM_SetCompare1 PROC
;;;2291     */
;;;2292   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000b40  8681              STRH     r1,[r0,#0x34]
;;;2293   {
;;;2294     /* Check the parameters */
;;;2295     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2296     /* Set the Capture Compare1 Register value */
;;;2297     TIMx->CCR1 = Compare1;
;;;2298   }
000b42  4770              BX       lr
;;;2299   
                          ENDP

                  TIM_SetCompare2 PROC
;;;2306     */
;;;2307   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000b44  8701              STRH     r1,[r0,#0x38]
;;;2308   {
;;;2309     /* Check the parameters */
;;;2310     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2311     /* Set the Capture Compare2 Register value */
;;;2312     TIMx->CCR2 = Compare2;
;;;2313   }
000b46  4770              BX       lr
;;;2314   
                          ENDP

                  TIM_SetCompare3 PROC
;;;2321     */
;;;2322   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000b48  8781              STRH     r1,[r0,#0x3c]
;;;2323   {
;;;2324     /* Check the parameters */
;;;2325     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2326     /* Set the Capture Compare3 Register value */
;;;2327     TIMx->CCR3 = Compare3;
;;;2328   }
000b4a  4770              BX       lr
;;;2329   
                          ENDP

                  TIM_SetCompare4 PROC
;;;2336     */
;;;2337   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000b4c  f8a01040          STRH     r1,[r0,#0x40]
;;;2338   {
;;;2339     /* Check the parameters */
;;;2340     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2341     /* Set the Capture Compare4 Register value */
;;;2342     TIMx->CCR4 = Compare4;
;;;2343   }
000b50  4770              BX       lr
;;;2344   
                          ENDP

                  TIM_SetClockDivision PROC
;;;2451     */
;;;2452   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000b52  8802              LDRH     r2,[r0,#0]
;;;2453   {
;;;2454     /* Check the parameters */
;;;2455     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2456     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2457     /* Reset the CKD Bits */
;;;2458     TIMx->CR1 &= CR1_CKD_Mask;
000b54  b2d2              UXTB     r2,r2
000b56  8002              STRH     r2,[r0,#0]
;;;2459     /* Set the CKD value */
;;;2460     TIMx->CR1 |= TIM_CKD;
000b58  8802              LDRH     r2,[r0,#0]
000b5a  430a              ORRS     r2,r2,r1
000b5c  8002              STRH     r2,[r0,#0]
;;;2461   }
000b5e  4770              BX       lr
;;;2462   
                          ENDP

                  TIM_GetCapture1 PROC
;;;2468     */
;;;2469   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000b60  4601              MOV      r1,r0
;;;2470   {
;;;2471     /* Check the parameters */
;;;2472     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2473     /* Get the Capture 1 Register value */
;;;2474     return TIMx->CCR1;
000b62  8e88              LDRH     r0,[r1,#0x34]
;;;2475   }
000b64  4770              BX       lr
;;;2476   
                          ENDP

                  TIM_GetCapture2 PROC
;;;2482     */
;;;2483   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000b66  4601              MOV      r1,r0
;;;2484   {
;;;2485     /* Check the parameters */
;;;2486     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2487     /* Get the Capture 2 Register value */
;;;2488     return TIMx->CCR2;
000b68  8f08              LDRH     r0,[r1,#0x38]
;;;2489   }
000b6a  4770              BX       lr
;;;2490   
                          ENDP

                  TIM_GetCapture3 PROC
;;;2496     */
;;;2497   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000b6c  4601              MOV      r1,r0
;;;2498   {
;;;2499     /* Check the parameters */
;;;2500     assert_param(IS_TIM_123458_PERIPH(TIMx)); 
;;;2501     /* Get the Capture 3 Register value */
;;;2502     return TIMx->CCR3;
000b6e  8f88              LDRH     r0,[r1,#0x3c]
;;;2503   }
000b70  4770              BX       lr
;;;2504   
                          ENDP

                  TIM_GetCapture4 PROC
;;;2510     */
;;;2511   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000b72  4601              MOV      r1,r0
;;;2512   {
;;;2513     /* Check the parameters */
;;;2514     assert_param(IS_TIM_123458_PERIPH(TIMx));
;;;2515     /* Get the Capture 4 Register value */
;;;2516     return TIMx->CCR4;
000b74  f8b10040          LDRH     r0,[r1,#0x40]
;;;2517   }
000b78  4770              BX       lr
;;;2518   
                          ENDP

                  TIM_GetCounter PROC
;;;2523     */
;;;2524   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000b7a  4601              MOV      r1,r0
;;;2525   {
;;;2526     /* Check the parameters */
;;;2527     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2528     /* Get the Counter Register value */
;;;2529     return TIMx->CNT;
000b7c  8c88              LDRH     r0,[r1,#0x24]
;;;2530   }
000b7e  4770              BX       lr
;;;2531   
                          ENDP

                  TIM_GetPrescaler PROC
;;;2536     */
;;;2537   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000b80  4601              MOV      r1,r0
;;;2538   {
;;;2539     /* Check the parameters */
;;;2540     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2541     /* Get the Prescaler Register value */
;;;2542     return TIMx->PSC;
000b82  8d08              LDRH     r0,[r1,#0x28]
;;;2543   }
000b84  4770              BX       lr
;;;2544   
                          ENDP

                  TIM_GetFlagStatus PROC
;;;2563     */
;;;2564   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000b86  4602              MOV      r2,r0
;;;2565   { 
;;;2566     ITStatus bitstatus = RESET;  
000b88  2000              MOVS     r0,#0
;;;2567     /* Check the parameters */
;;;2568     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2569     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2570     assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
;;;2571     
;;;2572     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000b8a  8a13              LDRH     r3,[r2,#0x10]
000b8c  400b              ANDS     r3,r3,r1
000b8e  b10b              CBZ      r3,|L1.2964|
;;;2573     {
;;;2574       bitstatus = SET;
000b90  2001              MOVS     r0,#1
000b92  e000              B        |L1.2966|
                  |L1.2964|
;;;2575     }
;;;2576     else
;;;2577     {
;;;2578       bitstatus = RESET;
000b94  2000              MOVS     r0,#0
                  |L1.2966|
;;;2579     }
;;;2580     return bitstatus;
;;;2581   }
000b96  4770              BX       lr
;;;2582   
                          ENDP

                  TIM_ClearFlag PROC
;;;2601     */
;;;2602   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000b98  43ca              MVNS     r2,r1
;;;2603   {  
;;;2604     /* Check the parameters */
;;;2605     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2606     assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
;;;2607      
;;;2608     /* Clear the flags */
;;;2609     TIMx->SR = (uint16_t)~TIM_FLAG;
000b9a  8202              STRH     r2,[r0,#0x10]
;;;2610   }
000b9c  4770              BX       lr
;;;2611   
                          ENDP

                  TIM_GetITStatus PROC
;;;2627     */
;;;2628   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000b9e  b530              PUSH     {r4,r5,lr}
;;;2629   {
000ba0  4602              MOV      r2,r0
;;;2630     ITStatus bitstatus = RESET;  
000ba2  2000              MOVS     r0,#0
;;;2631     uint16_t itstatus = 0x0, itenable = 0x0;
000ba4  2300              MOVS     r3,#0
000ba6  2400              MOVS     r4,#0
;;;2632     /* Check the parameters */
;;;2633     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2634     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2635     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2636      
;;;2637     itstatus = TIMx->SR & TIM_IT;
000ba8  8a15              LDRH     r5,[r2,#0x10]
000baa  ea050301          AND      r3,r5,r1
;;;2638     
;;;2639     itenable = TIMx->DIER & TIM_IT;
000bae  8995              LDRH     r5,[r2,#0xc]
000bb0  ea050401          AND      r4,r5,r1
;;;2640     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000bb4  b113              CBZ      r3,|L1.3004|
000bb6  b10c              CBZ      r4,|L1.3004|
;;;2641     {
;;;2642       bitstatus = SET;
000bb8  2001              MOVS     r0,#1
000bba  e000              B        |L1.3006|
                  |L1.3004|
;;;2643     }
;;;2644     else
;;;2645     {
;;;2646       bitstatus = RESET;
000bbc  2000              MOVS     r0,#0
                  |L1.3006|
;;;2647     }
;;;2648     return bitstatus;
;;;2649   }
000bbe  bd30              POP      {r4,r5,pc}
;;;2650   
                          ENDP

                  TIM_ClearITPendingBit PROC
;;;2666     */
;;;2667   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000bc0  43ca              MVNS     r2,r1
;;;2668   {
;;;2669     /* Check the parameters */
;;;2670     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2671     assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
;;;2672     /* Clear the IT pending Bit */
;;;2673     TIMx->SR = (uint16_t)~TIM_IT;
000bc2  8202              STRH     r2,[r0,#0x10]
;;;2674   }
000bc4  4770              BX       lr
;;;2675   
                          ENDP

