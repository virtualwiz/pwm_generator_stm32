; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\stm32f10x_flash.o --asm_dir=.\ --list_dir=.\ --depend=.\obj\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_flash.crf FWlib\SRC\stm32f10x_flash.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;124      */
;;;125    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4601              MOV      r1,r0
;;;126    {
;;;127      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;128      
;;;129      /* Check the parameters */
;;;130      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;131      
;;;132      /* Read the ACR register */
;;;133      tmpreg = FLASH->ACR;  
000004  4afb              LDR      r2,|L1.1012|
000006  6810              LDR      r0,[r2,#0]
;;;134      
;;;135      /* Sets the Latency value */
;;;136      tmpreg &= ACR_LATENCY_Mask;
000008  f0000038          AND      r0,r0,#0x38
;;;137      tmpreg |= FLASH_Latency;
00000c  4308              ORRS     r0,r0,r1
;;;138      
;;;139      /* Write the ACR register */
;;;140      FLASH->ACR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;141    }
000010  4770              BX       lr
;;;142    
                          ENDP

                  FLASH_HalfCycleAccessCmd PROC
;;;150      */
;;;151    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000012  49f8              LDR      r1,|L1.1012|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;155      
;;;156      /* Enable or disable the Half cycle access */
;;;157      FLASH->ACR &= ACR_HLFCYA_Mask;
000014  6809              LDR      r1,[r1,#0]
000016  f0210108          BIC      r1,r1,#8
00001a  4af6              LDR      r2,|L1.1012|
00001c  6011              STR      r1,[r2,#0]
;;;158      FLASH->ACR |= FLASH_HalfCycleAccess;
00001e  4611              MOV      r1,r2
000020  6809              LDR      r1,[r1,#0]
000022  4301              ORRS     r1,r1,r0
000024  6011              STR      r1,[r2,#0]
;;;159    }
000026  4770              BX       lr
;;;160    
                          ENDP

                  FLASH_PrefetchBufferCmd PROC
;;;168      */
;;;169    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000028  49f2              LDR      r1,|L1.1012|
;;;170    {
;;;171      /* Check the parameters */
;;;172      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;173      
;;;174      /* Enable or disable the Prefetch Buffer */
;;;175      FLASH->ACR &= ACR_PRFTBE_Mask;
00002a  6809              LDR      r1,[r1,#0]
00002c  f0210110          BIC      r1,r1,#0x10
000030  4af0              LDR      r2,|L1.1012|
000032  6011              STR      r1,[r2,#0]
;;;176      FLASH->ACR |= FLASH_PrefetchBuffer;
000034  4611              MOV      r1,r2
000036  6809              LDR      r1,[r1,#0]
000038  4301              ORRS     r1,r1,r0
00003a  6011              STR      r1,[r2,#0]
;;;177    }
00003c  4770              BX       lr
;;;178    
                          ENDP

                  FLASH_Unlock PROC
;;;183      */
;;;184    void FLASH_Unlock(void)
00003e  48ee              LDR      r0,|L1.1016|
;;;185    {
;;;186      /* Authorize the FPEC Access */
;;;187      FLASH->KEYR = FLASH_KEY1;
000040  49ec              LDR      r1,|L1.1012|
000042  6048              STR      r0,[r1,#4]
;;;188      FLASH->KEYR = FLASH_KEY2;
000044  48ed              LDR      r0,|L1.1020|
000046  6048              STR      r0,[r1,#4]
;;;189    }
000048  4770              BX       lr
;;;190    
                          ENDP

                  FLASH_Lock PROC
;;;195      */
;;;196    void FLASH_Lock(void)
00004a  48ea              LDR      r0,|L1.1012|
;;;197    {
;;;198      /* Set the Lock Bit to lock the FPEC and the FCR */
;;;199      FLASH->CR |= CR_LOCK_Set;
00004c  6900              LDR      r0,[r0,#0x10]
00004e  f0400080          ORR      r0,r0,#0x80
000052  49e8              LDR      r1,|L1.1012|
000054  6108              STR      r0,[r1,#0x10]
;;;200    }
000056  4770              BX       lr
;;;201    
                          ENDP

                  FLASH_GetStatus PROC
;;;797      */
;;;798    FLASH_Status FLASH_GetStatus(void)
000058  2004              MOVS     r0,#4
;;;799    {
;;;800      FLASH_Status flashstatus = FLASH_COMPLETE;
;;;801      
;;;802      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
00005a  49e6              LDR      r1,|L1.1012|
00005c  68c9              LDR      r1,[r1,#0xc]
00005e  f0010101          AND      r1,r1,#1
000062  b109              CBZ      r1,|L1.104|
;;;803      {
;;;804        flashstatus = FLASH_BUSY;
000064  2001              MOVS     r0,#1
000066  e00e              B        |L1.134|
                  |L1.104|
;;;805      }
;;;806      else 
;;;807      {  
;;;808        if(FLASH->SR & FLASH_FLAG_PGERR)
000068  49e2              LDR      r1,|L1.1012|
00006a  68c9              LDR      r1,[r1,#0xc]
00006c  f0010104          AND      r1,r1,#4
000070  b109              CBZ      r1,|L1.118|
;;;809        { 
;;;810          flashstatus = FLASH_ERROR_PG;
000072  2002              MOVS     r0,#2
000074  e007              B        |L1.134|
                  |L1.118|
;;;811        }
;;;812        else 
;;;813        {
;;;814          if(FLASH->SR & FLASH_FLAG_WRPRTERR)
000076  49df              LDR      r1,|L1.1012|
000078  68c9              LDR      r1,[r1,#0xc]
00007a  f0010110          AND      r1,r1,#0x10
00007e  b109              CBZ      r1,|L1.132|
;;;815          {
;;;816            flashstatus = FLASH_ERROR_WRP;
000080  2003              MOVS     r0,#3
000082  e000              B        |L1.134|
                  |L1.132|
;;;817          }
;;;818          else
;;;819          {
;;;820            flashstatus = FLASH_COMPLETE;
000084  2004              MOVS     r0,#4
                  |L1.134|
;;;821          }
;;;822        }
;;;823      }
;;;824      /* Return the Flash Status */
;;;825      return flashstatus;
;;;826    }
000086  4770              BX       lr
;;;827    
                          ENDP

                  delay PROC
;;;860      */
;;;861    static void delay(void)
000088  b508              PUSH     {r3,lr}
;;;862    {
;;;863      __IO uint32_t i = 0;
00008a  2000              MOVS     r0,#0
00008c  9000              STR      r0,[sp,#0]
;;;864      for(i = 0xFF; i != 0; i--)
00008e  20ff              MOVS     r0,#0xff
000090  9000              STR      r0,[sp,#0]
000092  e002              B        |L1.154|
                  |L1.148|
000094  9800              LDR      r0,[sp,#0]
000096  1e40              SUBS     r0,r0,#1
000098  9000              STR      r0,[sp,#0]
                  |L1.154|
00009a  9800              LDR      r0,[sp,#0]
00009c  2800              CMP      r0,#0
00009e  d1f9              BNE      |L1.148|
;;;865      {
;;;866      }
;;;867    }
0000a0  bd08              POP      {r3,pc}
;;;868    
                          ENDP

                  FLASH_WaitForLastOperation PROC
;;;834      */
;;;835    FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
0000a2  b570              PUSH     {r4-r6,lr}
;;;836    { 
0000a4  4604              MOV      r4,r0
;;;837      FLASH_Status status = FLASH_COMPLETE;
0000a6  2504              MOVS     r5,#4
;;;838       
;;;839      /* Check for the Flash Status */
;;;840      status = FLASH_GetStatus();
0000a8  f7fffffe          BL       FLASH_GetStatus
0000ac  4605              MOV      r5,r0
;;;841      /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;842      while((status == FLASH_BUSY) && (Timeout != 0x00))
0000ae  e005              B        |L1.188|
                  |L1.176|
;;;843      {
;;;844        delay();
0000b0  f7fffffe          BL       delay
;;;845        status = FLASH_GetStatus();
0000b4  f7fffffe          BL       FLASH_GetStatus
0000b8  4605              MOV      r5,r0
;;;846        Timeout--;
0000ba  1e64              SUBS     r4,r4,#1
                  |L1.188|
0000bc  2d01              CMP      r5,#1                 ;842
0000be  d101              BNE      |L1.196|
0000c0  2c00              CMP      r4,#0                 ;842
0000c2  d1f5              BNE      |L1.176|
                  |L1.196|
;;;847      }
;;;848      if(Timeout == 0x00 )
0000c4  b904              CBNZ     r4,|L1.200|
;;;849      {
;;;850        status = FLASH_TIMEOUT;
0000c6  2505              MOVS     r5,#5
                  |L1.200|
;;;851      }
;;;852      /* Return the operation status */
;;;853      return status;
0000c8  4628              MOV      r0,r5
;;;854    }
0000ca  bd70              POP      {r4-r6,pc}
;;;855    
                          ENDP

                  FLASH_ErasePage PROC
;;;208      */
;;;209    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
0000cc  b570              PUSH     {r4-r6,lr}
;;;210    {
0000ce  4605              MOV      r5,r0
;;;211      FLASH_Status status = FLASH_COMPLETE;
0000d0  2404              MOVS     r4,#4
;;;212      /* Check the parameters */
;;;213      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;214      /* Wait for last operation to be completed */
;;;215      status = FLASH_WaitForLastOperation(EraseTimeout);
0000d2  f64070ff          MOV      r0,#0xfff
0000d6  f7fffffe          BL       FLASH_WaitForLastOperation
0000da  4604              MOV      r4,r0
;;;216      
;;;217      if(status == FLASH_COMPLETE)
0000dc  2c04              CMP      r4,#4
0000de  d119              BNE      |L1.276|
;;;218      { 
;;;219        /* if the previous operation is completed, proceed to erase the page */
;;;220        FLASH->CR|= CR_PER_Set;
0000e0  48c4              LDR      r0,|L1.1012|
0000e2  6900              LDR      r0,[r0,#0x10]
0000e4  f0400002          ORR      r0,r0,#2
0000e8  49c2              LDR      r1,|L1.1012|
0000ea  6108              STR      r0,[r1,#0x10]
;;;221        FLASH->AR = Page_Address; 
0000ec  4608              MOV      r0,r1
0000ee  6145              STR      r5,[r0,#0x14]
;;;222        FLASH->CR|= CR_STRT_Set;
0000f0  6900              LDR      r0,[r0,#0x10]
0000f2  f0400040          ORR      r0,r0,#0x40
0000f6  6108              STR      r0,[r1,#0x10]
;;;223        
;;;224        /* Wait for last operation to be completed */
;;;225        status = FLASH_WaitForLastOperation(EraseTimeout);
0000f8  f64070ff          MOV      r0,#0xfff
0000fc  f7fffffe          BL       FLASH_WaitForLastOperation
000100  4604              MOV      r4,r0
;;;226        if(status != FLASH_BUSY)
000102  2c01              CMP      r4,#1
000104  d006              BEQ      |L1.276|
;;;227        {
;;;228          /* if the erase operation is completed, disable the PER Bit */
;;;229          FLASH->CR &= CR_PER_Reset;
000106  48bb              LDR      r0,|L1.1012|
000108  6900              LDR      r0,[r0,#0x10]
00010a  f64171fd          MOV      r1,#0x1ffd
00010e  4008              ANDS     r0,r0,r1
000110  49b8              LDR      r1,|L1.1012|
000112  6108              STR      r0,[r1,#0x10]
                  |L1.276|
;;;230        }
;;;231      }
;;;232      /* Return the Erase Status */
;;;233      return status;
000114  4620              MOV      r0,r4
;;;234    }
000116  bd70              POP      {r4-r6,pc}
;;;235    
                          ENDP

                  FLASH_EraseAllPages PROC
;;;242      */
;;;243    FLASH_Status FLASH_EraseAllPages(void)
000118  b510              PUSH     {r4,lr}
;;;244    {
;;;245      FLASH_Status status = FLASH_COMPLETE;
00011a  2404              MOVS     r4,#4
;;;246      /* Wait for last operation to be completed */
;;;247      status = FLASH_WaitForLastOperation(EraseTimeout);
00011c  f64070ff          MOV      r0,#0xfff
000120  f7fffffe          BL       FLASH_WaitForLastOperation
000124  4604              MOV      r4,r0
;;;248      
;;;249      if(status == FLASH_COMPLETE)
000126  2c04              CMP      r4,#4
000128  d118              BNE      |L1.348|
;;;250      {
;;;251        /* if the previous operation is completed, proceed to erase all pages */
;;;252         FLASH->CR |= CR_MER_Set;
00012a  48b2              LDR      r0,|L1.1012|
00012c  6900              LDR      r0,[r0,#0x10]
00012e  f0400004          ORR      r0,r0,#4
000132  49b0              LDR      r1,|L1.1012|
000134  6108              STR      r0,[r1,#0x10]
;;;253         FLASH->CR |= CR_STRT_Set;
000136  4608              MOV      r0,r1
000138  6900              LDR      r0,[r0,#0x10]
00013a  f0400040          ORR      r0,r0,#0x40
00013e  6108              STR      r0,[r1,#0x10]
;;;254        
;;;255        /* Wait for last operation to be completed */
;;;256        status = FLASH_WaitForLastOperation(EraseTimeout);
000140  f64070ff          MOV      r0,#0xfff
000144  f7fffffe          BL       FLASH_WaitForLastOperation
000148  4604              MOV      r4,r0
;;;257        if(status != FLASH_BUSY)
00014a  2c01              CMP      r4,#1
00014c  d006              BEQ      |L1.348|
;;;258        {
;;;259          /* if the erase operation is completed, disable the MER Bit */
;;;260          FLASH->CR &= CR_MER_Reset;
00014e  48a9              LDR      r0,|L1.1012|
000150  6900              LDR      r0,[r0,#0x10]
000152  f64171fb          MOV      r1,#0x1ffb
000156  4008              ANDS     r0,r0,r1
000158  49a6              LDR      r1,|L1.1012|
00015a  6108              STR      r0,[r1,#0x10]
                  |L1.348|
;;;261        }
;;;262      }	   
;;;263      /* Return the Erase Status */
;;;264      return status;
00015c  4620              MOV      r0,r4
;;;265    }
00015e  bd10              POP      {r4,pc}
;;;266    
                          ENDP

                  FLASH_EraseOptionBytes PROC
;;;273      */
;;;274    FLASH_Status FLASH_EraseOptionBytes(void)
000160  b510              PUSH     {r4,lr}
;;;275    {
;;;276      FLASH_Status status = FLASH_COMPLETE;
000162  2404              MOVS     r4,#4
;;;277      
;;;278      /* Wait for last operation to be completed */
;;;279      status = FLASH_WaitForLastOperation(EraseTimeout);
000164  f64070ff          MOV      r0,#0xfff
000168  f7fffffe          BL       FLASH_WaitForLastOperation
00016c  4604              MOV      r4,r0
;;;280      if(status == FLASH_COMPLETE)
00016e  2c04              CMP      r4,#4
000170  d13b              BNE      |L1.490|
;;;281      {
;;;282        /* Authorize the small information block programming */
;;;283        FLASH->OPTKEYR = FLASH_KEY1;
000172  48a1              LDR      r0,|L1.1016|
000174  499f              LDR      r1,|L1.1012|
000176  6088              STR      r0,[r1,#8]
;;;284        FLASH->OPTKEYR = FLASH_KEY2;
000178  48a0              LDR      r0,|L1.1020|
00017a  6088              STR      r0,[r1,#8]
;;;285        
;;;286        /* if the previous operation is completed, proceed to erase the option bytes */
;;;287        FLASH->CR |= CR_OPTER_Set;
00017c  4608              MOV      r0,r1
00017e  6900              LDR      r0,[r0,#0x10]
000180  f0400020          ORR      r0,r0,#0x20
000184  6108              STR      r0,[r1,#0x10]
;;;288        FLASH->CR |= CR_STRT_Set;
000186  4608              MOV      r0,r1
000188  6900              LDR      r0,[r0,#0x10]
00018a  f0400040          ORR      r0,r0,#0x40
00018e  6108              STR      r0,[r1,#0x10]
;;;289        /* Wait for last operation to be completed */
;;;290        status = FLASH_WaitForLastOperation(EraseTimeout);
000190  f64070ff          MOV      r0,#0xfff
000194  f7fffffe          BL       FLASH_WaitForLastOperation
000198  4604              MOV      r4,r0
;;;291        
;;;292        if(status == FLASH_COMPLETE)
00019a  2c04              CMP      r4,#4
00019c  d11c              BNE      |L1.472|
;;;293        {
;;;294          /* if the erase operation is completed, disable the OPTER Bit */
;;;295          FLASH->CR &= CR_OPTER_Reset;
00019e  4895              LDR      r0,|L1.1012|
0001a0  6900              LDR      r0,[r0,#0x10]
0001a2  f64171df          MOV      r1,#0x1fdf
0001a6  4008              ANDS     r0,r0,r1
0001a8  4992              LDR      r1,|L1.1012|
0001aa  6108              STR      r0,[r1,#0x10]
;;;296           
;;;297          /* Enable the Option Bytes Programming operation */
;;;298          FLASH->CR |= CR_OPTPG_Set;
0001ac  4608              MOV      r0,r1
0001ae  6900              LDR      r0,[r0,#0x10]
0001b0  f0400010          ORR      r0,r0,#0x10
0001b4  6108              STR      r0,[r1,#0x10]
;;;299          /* Enable the readout access */
;;;300          OB->RDP= RDP_Key; 
0001b6  20a5              MOVS     r0,#0xa5
0001b8  4991              LDR      r1,|L1.1024|
0001ba  8008              STRH     r0,[r1,#0]
;;;301          /* Wait for last operation to be completed */
;;;302          status = FLASH_WaitForLastOperation(ProgramTimeout);
0001bc  200f              MOVS     r0,#0xf
0001be  f7fffffe          BL       FLASH_WaitForLastOperation
0001c2  4604              MOV      r4,r0
;;;303     
;;;304          if(status != FLASH_BUSY)
0001c4  2c01              CMP      r4,#1
0001c6  d010              BEQ      |L1.490|
;;;305          {
;;;306            /* if the program operation is completed, disable the OPTPG Bit */
;;;307            FLASH->CR &= CR_OPTPG_Reset;
0001c8  488a              LDR      r0,|L1.1012|
0001ca  6900              LDR      r0,[r0,#0x10]
0001cc  f64171ef          MOV      r1,#0x1fef
0001d0  4008              ANDS     r0,r0,r1
0001d2  4988              LDR      r1,|L1.1012|
0001d4  6108              STR      r0,[r1,#0x10]
0001d6  e008              B        |L1.490|
                  |L1.472|
;;;308          }
;;;309        }
;;;310        else
;;;311        {
;;;312          if (status != FLASH_BUSY)
0001d8  2c01              CMP      r4,#1
0001da  d006              BEQ      |L1.490|
;;;313          {
;;;314            /* Disable the OPTPG Bit */
;;;315            FLASH->CR &= CR_OPTPG_Reset;
0001dc  4885              LDR      r0,|L1.1012|
0001de  6900              LDR      r0,[r0,#0x10]
0001e0  f64171ef          MOV      r1,#0x1fef
0001e4  4008              ANDS     r0,r0,r1
0001e6  4983              LDR      r1,|L1.1012|
0001e8  6108              STR      r0,[r1,#0x10]
                  |L1.490|
;;;316          }
;;;317        }  
;;;318      }
;;;319      /* Return the erase status */
;;;320      return status;
0001ea  4620              MOV      r0,r4
;;;321    }
0001ec  bd10              POP      {r4,pc}
;;;322    
                          ENDP

                  FLASH_ProgramWord PROC
;;;330      */
;;;331    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
0001ee  b570              PUSH     {r4-r6,lr}
;;;332    {
0001f0  4605              MOV      r5,r0
0001f2  460e              MOV      r6,r1
;;;333      FLASH_Status status = FLASH_COMPLETE;
0001f4  2404              MOVS     r4,#4
;;;334      /* Check the parameters */
;;;335      assert_param(IS_FLASH_ADDRESS(Address));
;;;336      /* Wait for last operation to be completed */
;;;337      status = FLASH_WaitForLastOperation(ProgramTimeout);
0001f6  200f              MOVS     r0,#0xf
0001f8  f7fffffe          BL       FLASH_WaitForLastOperation
0001fc  4604              MOV      r4,r0
;;;338      
;;;339      if(status == FLASH_COMPLETE)
0001fe  2c04              CMP      r4,#4
000200  d125              BNE      |L1.590|
;;;340      {
;;;341        /* if the previous operation is completed, proceed to program the new first 
;;;342        half word */
;;;343        FLASH->CR |= CR_PG_Set;
000202  487c              LDR      r0,|L1.1012|
000204  6900              LDR      r0,[r0,#0x10]
000206  f0400001          ORR      r0,r0,#1
00020a  497a              LDR      r1,|L1.1012|
00020c  6108              STR      r0,[r1,#0x10]
;;;344      
;;;345        *(__IO uint16_t*)Address = (uint16_t)Data;
00020e  802e              STRH     r6,[r5,#0]
;;;346        /* Wait for last operation to be completed */
;;;347        status = FLASH_WaitForLastOperation(ProgramTimeout);
000210  200f              MOVS     r0,#0xf
000212  f7fffffe          BL       FLASH_WaitForLastOperation
000216  4604              MOV      r4,r0
;;;348     
;;;349        if(status == FLASH_COMPLETE)
000218  2c04              CMP      r4,#4
00021a  d10f              BNE      |L1.572|
;;;350        {
;;;351          /* if the previous operation is completed, proceed to program the new second 
;;;352          half word */
;;;353          *(__IO uint16_t*)(Address + 2) = Data >> 16;
00021c  0c30              LSRS     r0,r6,#16
00021e  8068              STRH     r0,[r5,#2]
;;;354        
;;;355          /* Wait for last operation to be completed */
;;;356          status = FLASH_WaitForLastOperation(ProgramTimeout);
000220  200f              MOVS     r0,#0xf
000222  f7fffffe          BL       FLASH_WaitForLastOperation
000226  4604              MOV      r4,r0
;;;357            
;;;358          if(status != FLASH_BUSY)
000228  2c01              CMP      r4,#1
00022a  d010              BEQ      |L1.590|
;;;359          {
;;;360            /* Disable the PG Bit */
;;;361            FLASH->CR &= CR_PG_Reset;
00022c  4871              LDR      r0,|L1.1012|
00022e  6900              LDR      r0,[r0,#0x10]
000230  f64171fe          MOV      r1,#0x1ffe
000234  4008              ANDS     r0,r0,r1
000236  496f              LDR      r1,|L1.1012|
000238  6108              STR      r0,[r1,#0x10]
00023a  e008              B        |L1.590|
                  |L1.572|
;;;362          }
;;;363        }
;;;364        else
;;;365        {
;;;366          if (status != FLASH_BUSY)
00023c  2c01              CMP      r4,#1
00023e  d006              BEQ      |L1.590|
;;;367          {
;;;368            /* Disable the PG Bit */
;;;369            FLASH->CR &= CR_PG_Reset;
000240  486c              LDR      r0,|L1.1012|
000242  6900              LDR      r0,[r0,#0x10]
000244  f64171fe          MOV      r1,#0x1ffe
000248  4008              ANDS     r0,r0,r1
00024a  496a              LDR      r1,|L1.1012|
00024c  6108              STR      r0,[r1,#0x10]
                  |L1.590|
;;;370          }
;;;371         }
;;;372      }
;;;373      /* Return the Program Status */
;;;374      return status;
00024e  4620              MOV      r0,r4
;;;375    }
000250  bd70              POP      {r4-r6,pc}
;;;376    
                          ENDP

                  FLASH_ProgramHalfWord PROC
;;;384      */
;;;385    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000252  b570              PUSH     {r4-r6,lr}
;;;386    {
000254  4605              MOV      r5,r0
000256  460e              MOV      r6,r1
;;;387      FLASH_Status status = FLASH_COMPLETE;
000258  2404              MOVS     r4,#4
;;;388      /* Check the parameters */
;;;389      assert_param(IS_FLASH_ADDRESS(Address));
;;;390      /* Wait for last operation to be completed */
;;;391      status = FLASH_WaitForLastOperation(ProgramTimeout);
00025a  200f              MOVS     r0,#0xf
00025c  f7fffffe          BL       FLASH_WaitForLastOperation
000260  4604              MOV      r4,r0
;;;392      
;;;393      if(status == FLASH_COMPLETE)
000262  2c04              CMP      r4,#4
000264  d113              BNE      |L1.654|
;;;394      {
;;;395        /* if the previous operation is completed, proceed to program the new data */
;;;396        FLASH->CR |= CR_PG_Set;
000266  4863              LDR      r0,|L1.1012|
000268  6900              LDR      r0,[r0,#0x10]
00026a  f0400001          ORR      r0,r0,#1
00026e  4961              LDR      r1,|L1.1012|
000270  6108              STR      r0,[r1,#0x10]
;;;397      
;;;398        *(__IO uint16_t*)Address = Data;
000272  802e              STRH     r6,[r5,#0]
;;;399        /* Wait for last operation to be completed */
;;;400        status = FLASH_WaitForLastOperation(ProgramTimeout);
000274  200f              MOVS     r0,#0xf
000276  f7fffffe          BL       FLASH_WaitForLastOperation
00027a  4604              MOV      r4,r0
;;;401        if(status != FLASH_BUSY)
00027c  2c01              CMP      r4,#1
00027e  d006              BEQ      |L1.654|
;;;402        {
;;;403          /* if the program operation is completed, disable the PG Bit */
;;;404          FLASH->CR &= CR_PG_Reset;
000280  485c              LDR      r0,|L1.1012|
000282  6900              LDR      r0,[r0,#0x10]
000284  f64171fe          MOV      r1,#0x1ffe
000288  4008              ANDS     r0,r0,r1
00028a  495a              LDR      r1,|L1.1012|
00028c  6108              STR      r0,[r1,#0x10]
                  |L1.654|
;;;405        }
;;;406      } 
;;;407      /* Return the Program Status */
;;;408      return status;
00028e  4620              MOV      r0,r4
;;;409    }
000290  bd70              POP      {r4-r6,pc}
;;;410    
                          ENDP

                  FLASH_ProgramOptionByteData PROC
;;;419      */
;;;420    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000292  b570              PUSH     {r4-r6,lr}
;;;421    {
000294  4605              MOV      r5,r0
000296  460e              MOV      r6,r1
;;;422      FLASH_Status status = FLASH_COMPLETE;
000298  2404              MOVS     r4,#4
;;;423      /* Check the parameters */
;;;424      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;425      status = FLASH_WaitForLastOperation(ProgramTimeout);
00029a  200f              MOVS     r0,#0xf
00029c  f7fffffe          BL       FLASH_WaitForLastOperation
0002a0  4604              MOV      r4,r0
;;;426      if(status == FLASH_COMPLETE)
0002a2  2c04              CMP      r4,#4
0002a4  d117              BNE      |L1.726|
;;;427      {
;;;428        /* Authorize the small information block programming */
;;;429        FLASH->OPTKEYR = FLASH_KEY1;
0002a6  4854              LDR      r0,|L1.1016|
0002a8  4952              LDR      r1,|L1.1012|
0002aa  6088              STR      r0,[r1,#8]
;;;430        FLASH->OPTKEYR = FLASH_KEY2;
0002ac  4853              LDR      r0,|L1.1020|
0002ae  6088              STR      r0,[r1,#8]
;;;431        /* Enables the Option Bytes Programming operation */
;;;432        FLASH->CR |= CR_OPTPG_Set; 
0002b0  4608              MOV      r0,r1
0002b2  6900              LDR      r0,[r0,#0x10]
0002b4  f0400010          ORR      r0,r0,#0x10
0002b8  6108              STR      r0,[r1,#0x10]
;;;433        *(__IO uint16_t*)Address = Data;
0002ba  802e              STRH     r6,[r5,#0]
;;;434        
;;;435        /* Wait for last operation to be completed */
;;;436        status = FLASH_WaitForLastOperation(ProgramTimeout);
0002bc  200f              MOVS     r0,#0xf
0002be  f7fffffe          BL       FLASH_WaitForLastOperation
0002c2  4604              MOV      r4,r0
;;;437        if(status != FLASH_BUSY)
0002c4  2c01              CMP      r4,#1
0002c6  d006              BEQ      |L1.726|
;;;438        {
;;;439          /* if the program operation is completed, disable the OPTPG Bit */
;;;440          FLASH->CR &= CR_OPTPG_Reset;
0002c8  484a              LDR      r0,|L1.1012|
0002ca  6900              LDR      r0,[r0,#0x10]
0002cc  f64171ef          MOV      r1,#0x1fef
0002d0  4008              ANDS     r0,r0,r1
0002d2  4948              LDR      r1,|L1.1012|
0002d4  6108              STR      r0,[r1,#0x10]
                  |L1.726|
;;;441        }
;;;442      }    
;;;443      /* Return the Option Byte Data Program Status */
;;;444      return status;
0002d6  4620              MOV      r0,r4
;;;445    }
0002d8  bd70              POP      {r4-r6,pc}
;;;446    
                          ENDP

                  FLASH_EnableWriteProtection PROC
;;;460      */
;;;461    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
0002da  e92d47f0          PUSH     {r4-r10,lr}
;;;462    {
0002de  4604              MOV      r4,r0
;;;463      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
0002e0  f64f76ff          MOV      r6,#0xffff
0002e4  4637              MOV      r7,r6
0002e6  46b0              MOV      r8,r6
0002e8  46b1              MOV      r9,r6
;;;464      
;;;465      FLASH_Status status = FLASH_COMPLETE;
0002ea  2504              MOVS     r5,#4
;;;466      
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;469      
;;;470      FLASH_Pages = (uint32_t)(~FLASH_Pages);
0002ec  43e4              MVNS     r4,r4
;;;471      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
0002ee  b2e6              UXTB     r6,r4
;;;472      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
0002f0  f3c42707          UBFX     r7,r4,#8,#8
;;;473      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
0002f4  f3c44807          UBFX     r8,r4,#16,#8
;;;474      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
0002f8  ea4f6914          LSR      r9,r4,#24
;;;475      
;;;476      /* Wait for last operation to be completed */
;;;477      status = FLASH_WaitForLastOperation(ProgramTimeout);
0002fc  200f              MOVS     r0,#0xf
0002fe  f7fffffe          BL       FLASH_WaitForLastOperation
000302  4605              MOV      r5,r0
;;;478      
;;;479      if(status == FLASH_COMPLETE)
000304  2d04              CMP      r5,#4
000306  d140              BNE      |L1.906|
;;;480      {
;;;481        /* Authorizes the small information block programming */
;;;482        FLASH->OPTKEYR = FLASH_KEY1;
000308  483b              LDR      r0,|L1.1016|
00030a  493a              LDR      r1,|L1.1012|
00030c  6088              STR      r0,[r1,#8]
;;;483        FLASH->OPTKEYR = FLASH_KEY2;
00030e  483b              LDR      r0,|L1.1020|
000310  6088              STR      r0,[r1,#8]
;;;484        FLASH->CR |= CR_OPTPG_Set;
000312  4608              MOV      r0,r1
000314  6900              LDR      r0,[r0,#0x10]
000316  f0400010          ORR      r0,r0,#0x10
00031a  6108              STR      r0,[r1,#0x10]
;;;485        if(WRP0_Data != 0xFF)
00031c  2eff              CMP      r6,#0xff
00031e  d006              BEQ      |L1.814|
;;;486        {
;;;487          OB->WRP0 = WRP0_Data;
000320  4837              LDR      r0,|L1.1024|
000322  3008              ADDS     r0,r0,#8
000324  8006              STRH     r6,[r0,#0]
;;;488          
;;;489          /* Wait for last operation to be completed */
;;;490          status = FLASH_WaitForLastOperation(ProgramTimeout);
000326  200f              MOVS     r0,#0xf
000328  f7fffffe          BL       FLASH_WaitForLastOperation
00032c  4605              MOV      r5,r0
                  |L1.814|
;;;491        }
;;;492        if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
00032e  2d04              CMP      r5,#4
000330  d108              BNE      |L1.836|
000332  2fff              CMP      r7,#0xff
000334  d006              BEQ      |L1.836|
;;;493        {
;;;494          OB->WRP1 = WRP1_Data;
000336  4832              LDR      r0,|L1.1024|
000338  300a              ADDS     r0,r0,#0xa
00033a  8007              STRH     r7,[r0,#0]
;;;495          
;;;496          /* Wait for last operation to be completed */
;;;497          status = FLASH_WaitForLastOperation(ProgramTimeout);
00033c  200f              MOVS     r0,#0xf
00033e  f7fffffe          BL       FLASH_WaitForLastOperation
000342  4605              MOV      r5,r0
                  |L1.836|
;;;498        }
;;;499        if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000344  2d04              CMP      r5,#4
000346  d10a              BNE      |L1.862|
000348  f1b80fff          CMP      r8,#0xff
00034c  d007              BEQ      |L1.862|
;;;500        {
;;;501          OB->WRP2 = WRP2_Data;
00034e  482c              LDR      r0,|L1.1024|
000350  300c              ADDS     r0,r0,#0xc
000352  f8a08000          STRH     r8,[r0,#0]
;;;502          
;;;503          /* Wait for last operation to be completed */
;;;504          status = FLASH_WaitForLastOperation(ProgramTimeout);
000356  200f              MOVS     r0,#0xf
000358  f7fffffe          BL       FLASH_WaitForLastOperation
00035c  4605              MOV      r5,r0
                  |L1.862|
;;;505        }
;;;506        
;;;507        if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
00035e  2d04              CMP      r5,#4
000360  d10a              BNE      |L1.888|
000362  f1b90fff          CMP      r9,#0xff
000366  d007              BEQ      |L1.888|
;;;508        {
;;;509          OB->WRP3 = WRP3_Data;
000368  4825              LDR      r0,|L1.1024|
00036a  300e              ADDS     r0,r0,#0xe
00036c  f8a09000          STRH     r9,[r0,#0]
;;;510         
;;;511          /* Wait for last operation to be completed */
;;;512          status = FLASH_WaitForLastOperation(ProgramTimeout);
000370  200f              MOVS     r0,#0xf
000372  f7fffffe          BL       FLASH_WaitForLastOperation
000376  4605              MOV      r5,r0
                  |L1.888|
;;;513        }
;;;514              
;;;515        if(status != FLASH_BUSY)
000378  2d01              CMP      r5,#1
00037a  d006              BEQ      |L1.906|
;;;516        {
;;;517          /* if the program operation is completed, disable the OPTPG Bit */
;;;518          FLASH->CR &= CR_OPTPG_Reset;
00037c  481d              LDR      r0,|L1.1012|
00037e  6900              LDR      r0,[r0,#0x10]
000380  f64171ef          MOV      r1,#0x1fef
000384  4008              ANDS     r0,r0,r1
000386  491b              LDR      r1,|L1.1012|
000388  6108              STR      r0,[r1,#0x10]
                  |L1.906|
;;;519        }
;;;520      } 
;;;521      /* Return the write protection operation Status */
;;;522      return status;       
00038a  4628              MOV      r0,r5
;;;523    }
00038c  e8bd87f0          POP      {r4-r10,pc}
;;;524    
                          ENDP

                  FLASH_ReadOutProtection PROC
;;;535      */
;;;536    FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000390  b570              PUSH     {r4-r6,lr}
;;;537    {
000392  4605              MOV      r5,r0
;;;538      FLASH_Status status = FLASH_COMPLETE;
000394  2404              MOVS     r4,#4
;;;539      /* Check the parameters */
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      status = FLASH_WaitForLastOperation(EraseTimeout);
000396  f64070ff          MOV      r0,#0xfff
00039a  f7fffffe          BL       FLASH_WaitForLastOperation
00039e  4604              MOV      r4,r0
;;;542      if(status == FLASH_COMPLETE)
0003a0  2c04              CMP      r4,#4
0003a2  d14a              BNE      |L1.1082|
;;;543      {
;;;544        /* Authorizes the small information block programming */
;;;545        FLASH->OPTKEYR = FLASH_KEY1;
0003a4  4814              LDR      r0,|L1.1016|
0003a6  4913              LDR      r1,|L1.1012|
0003a8  6088              STR      r0,[r1,#8]
;;;546        FLASH->OPTKEYR = FLASH_KEY2;
0003aa  4814              LDR      r0,|L1.1020|
0003ac  6088              STR      r0,[r1,#8]
;;;547        FLASH->CR |= CR_OPTER_Set;
0003ae  4608              MOV      r0,r1
0003b0  6900              LDR      r0,[r0,#0x10]
0003b2  f0400020          ORR      r0,r0,#0x20
0003b6  6108              STR      r0,[r1,#0x10]
;;;548        FLASH->CR |= CR_STRT_Set;
0003b8  4608              MOV      r0,r1
0003ba  6900              LDR      r0,[r0,#0x10]
0003bc  f0400040          ORR      r0,r0,#0x40
0003c0  6108              STR      r0,[r1,#0x10]
;;;549        /* Wait for last operation to be completed */
;;;550        status = FLASH_WaitForLastOperation(EraseTimeout);
0003c2  f64070ff          MOV      r0,#0xfff
0003c6  f7fffffe          BL       FLASH_WaitForLastOperation
0003ca  4604              MOV      r4,r0
;;;551        if(status == FLASH_COMPLETE)
0003cc  2c04              CMP      r4,#4
0003ce  d12b              BNE      |L1.1064|
;;;552        {
;;;553          /* if the erase operation is completed, disable the OPTER Bit */
;;;554          FLASH->CR &= CR_OPTER_Reset;
0003d0  4808              LDR      r0,|L1.1012|
0003d2  6900              LDR      r0,[r0,#0x10]
0003d4  f64171df          MOV      r1,#0x1fdf
0003d8  4008              ANDS     r0,r0,r1
0003da  4906              LDR      r1,|L1.1012|
0003dc  6108              STR      r0,[r1,#0x10]
;;;555          /* Enable the Option Bytes Programming operation */
;;;556          FLASH->CR |= CR_OPTPG_Set; 
0003de  4608              MOV      r0,r1
0003e0  6900              LDR      r0,[r0,#0x10]
0003e2  f0400010          ORR      r0,r0,#0x10
0003e6  6108              STR      r0,[r1,#0x10]
;;;557          if(NewState != DISABLE)
0003e8  b165              CBZ      r5,|L1.1028|
;;;558          {
;;;559            OB->RDP = 0x00;
0003ea  2000              MOVS     r0,#0
0003ec  4904              LDR      r1,|L1.1024|
0003ee  8008              STRH     r0,[r1,#0]
0003f0  e00b              B        |L1.1034|
0003f2  0000              DCW      0x0000
                  |L1.1012|
                          DCD      0x40022000
                  |L1.1016|
                          DCD      0x45670123
                  |L1.1020|
                          DCD      0xcdef89ab
                  |L1.1024|
                          DCD      0x1ffff800
                  |L1.1028|
;;;560          }
;;;561          else
;;;562          {
;;;563            OB->RDP = RDP_Key;  
000404  20a5              MOVS     r0,#0xa5
000406  4945              LDR      r1,|L1.1308|
000408  8008              STRH     r0,[r1,#0]
                  |L1.1034|
;;;564          }
;;;565          /* Wait for last operation to be completed */
;;;566          status = FLASH_WaitForLastOperation(EraseTimeout); 
00040a  f64070ff          MOV      r0,#0xfff
00040e  f7fffffe          BL       FLASH_WaitForLastOperation
000412  4604              MOV      r4,r0
;;;567        
;;;568          if(status != FLASH_BUSY)
000414  2c01              CMP      r4,#1
000416  d010              BEQ      |L1.1082|
;;;569          {
;;;570            /* if the program operation is completed, disable the OPTPG Bit */
;;;571            FLASH->CR &= CR_OPTPG_Reset;
000418  4841              LDR      r0,|L1.1312|
00041a  6900              LDR      r0,[r0,#0x10]
00041c  f64171ef          MOV      r1,#0x1fef
000420  4008              ANDS     r0,r0,r1
000422  493f              LDR      r1,|L1.1312|
000424  6108              STR      r0,[r1,#0x10]
000426  e008              B        |L1.1082|
                  |L1.1064|
;;;572          }
;;;573        }
;;;574        else 
;;;575        {
;;;576          if(status != FLASH_BUSY)
000428  2c01              CMP      r4,#1
00042a  d006              BEQ      |L1.1082|
;;;577          {
;;;578            /* Disable the OPTER Bit */
;;;579            FLASH->CR &= CR_OPTER_Reset;
00042c  483c              LDR      r0,|L1.1312|
00042e  6900              LDR      r0,[r0,#0x10]
000430  f64171df          MOV      r1,#0x1fdf
000434  4008              ANDS     r0,r0,r1
000436  493a              LDR      r1,|L1.1312|
000438  6108              STR      r0,[r1,#0x10]
                  |L1.1082|
;;;580          }
;;;581        }
;;;582      }
;;;583      /* Return the protection operation Status */
;;;584      return status;      
00043a  4620              MOV      r0,r4
;;;585    }
00043c  bd70              POP      {r4-r6,pc}
;;;586    
                          ENDP

                  FLASH_UserOptionByteConfig PROC
;;;605      */
;;;606    FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
00043e  e92d41f0          PUSH     {r4-r8,lr}
;;;607    {
000442  4607              MOV      r7,r0
000444  460d              MOV      r5,r1
000446  4616              MOV      r6,r2
;;;608      FLASH_Status status = FLASH_COMPLETE; 
000448  2404              MOVS     r4,#4
;;;609      /* Check the parameters */
;;;610      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;611      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;612      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;613      /* Authorize the small information block programming */
;;;614      FLASH->OPTKEYR = FLASH_KEY1;
00044a  4836              LDR      r0,|L1.1316|
00044c  4934              LDR      r1,|L1.1312|
00044e  6088              STR      r0,[r1,#8]
;;;615      FLASH->OPTKEYR = FLASH_KEY2;
000450  4835              LDR      r0,|L1.1320|
000452  6088              STR      r0,[r1,#8]
;;;616      
;;;617      /* Wait for last operation to be completed */
;;;618      status = FLASH_WaitForLastOperation(ProgramTimeout);
000454  200f              MOVS     r0,#0xf
000456  f7fffffe          BL       FLASH_WaitForLastOperation
00045a  4604              MOV      r4,r0
;;;619      
;;;620      if(status == FLASH_COMPLETE)
00045c  2c04              CMP      r4,#4
00045e  d11a              BNE      |L1.1174|
;;;621      {  
;;;622        /* Enable the Option Bytes Programming operation */
;;;623        FLASH->CR |= CR_OPTPG_Set; 
000460  482f              LDR      r0,|L1.1312|
000462  6900              LDR      r0,[r0,#0x10]
000464  f0400010          ORR      r0,r0,#0x10
000468  492d              LDR      r1,|L1.1312|
00046a  6108              STR      r0,[r1,#0x10]
;;;624               
;;;625        OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (uint16_t)0xF8; 
00046c  ea470005          ORR      r0,r7,r5
000470  4330              ORRS     r0,r0,r6
000472  f04000f8          ORR      r0,r0,#0xf8
000476  4929              LDR      r1,|L1.1308|
000478  1c89              ADDS     r1,r1,#2
00047a  8008              STRH     r0,[r1,#0]
;;;626      
;;;627        /* Wait for last operation to be completed */
;;;628        status = FLASH_WaitForLastOperation(ProgramTimeout);
00047c  200f              MOVS     r0,#0xf
00047e  f7fffffe          BL       FLASH_WaitForLastOperation
000482  4604              MOV      r4,r0
;;;629        if(status != FLASH_BUSY)
000484  2c01              CMP      r4,#1
000486  d006              BEQ      |L1.1174|
;;;630        {
;;;631          /* if the program operation is completed, disable the OPTPG Bit */
;;;632          FLASH->CR &= CR_OPTPG_Reset;
000488  4825              LDR      r0,|L1.1312|
00048a  6900              LDR      r0,[r0,#0x10]
00048c  f64171ef          MOV      r1,#0x1fef
000490  4008              ANDS     r0,r0,r1
000492  4923              LDR      r1,|L1.1312|
000494  6108              STR      r0,[r1,#0x10]
                  |L1.1174|
;;;633        }
;;;634      }    
;;;635      /* Return the Option Byte program Status */
;;;636      return status;
000496  4620              MOV      r0,r4
;;;637    }
000498  e8bd81f0          POP      {r4-r8,pc}
;;;638    
                          ENDP

                  FLASH_GetUserOptionByte PROC
;;;644      */
;;;645    uint32_t FLASH_GetUserOptionByte(void)
00049c  4820              LDR      r0,|L1.1312|
;;;646    {
;;;647      /* Return the User Option Byte */
;;;648      return (uint32_t)(FLASH->OBR >> 2);
00049e  69c0              LDR      r0,[r0,#0x1c]
0004a0  0880              LSRS     r0,r0,#2
;;;649    }
0004a2  4770              BX       lr
;;;650    
                          ENDP

                  FLASH_GetWriteProtectionOptionByte PROC
;;;655      */
;;;656    uint32_t FLASH_GetWriteProtectionOptionByte(void)
0004a4  481e              LDR      r0,|L1.1312|
;;;657    {
;;;658      /* Return the Falsh write protection Register value */
;;;659      return (uint32_t)(FLASH->WRPR);
0004a6  6a00              LDR      r0,[r0,#0x20]
;;;660    }
0004a8  4770              BX       lr
;;;661    
                          ENDP

                  FLASH_GetReadOutProtectionStatus PROC
;;;667      */
;;;668    FlagStatus FLASH_GetReadOutProtectionStatus(void)
0004aa  2000              MOVS     r0,#0
;;;669    {
;;;670      FlagStatus readoutstatus = RESET;
;;;671      if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
0004ac  491c              LDR      r1,|L1.1312|
0004ae  69c9              LDR      r1,[r1,#0x1c]
0004b0  f0010102          AND      r1,r1,#2
0004b4  b109              CBZ      r1,|L1.1210|
;;;672      {
;;;673        readoutstatus = SET;
0004b6  2001              MOVS     r0,#1
0004b8  e000              B        |L1.1212|
                  |L1.1210|
;;;674      }
;;;675      else
;;;676      {
;;;677        readoutstatus = RESET;
0004ba  2000              MOVS     r0,#0
                  |L1.1212|
;;;678      }
;;;679      return readoutstatus;
;;;680    }
0004bc  4770              BX       lr
;;;681    
                          ENDP

                  FLASH_GetPrefetchBufferStatus PROC
;;;686      */
;;;687    FlagStatus FLASH_GetPrefetchBufferStatus(void)
0004be  2000              MOVS     r0,#0
;;;688    {
;;;689      FlagStatus bitstatus = RESET;
;;;690      
;;;691      if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
0004c0  4917              LDR      r1,|L1.1312|
0004c2  6809              LDR      r1,[r1,#0]
0004c4  f0010120          AND      r1,r1,#0x20
0004c8  b109              CBZ      r1,|L1.1230|
;;;692      {
;;;693        bitstatus = SET;
0004ca  2001              MOVS     r0,#1
0004cc  e000              B        |L1.1232|
                  |L1.1230|
;;;694      }
;;;695      else
;;;696      {
;;;697        bitstatus = RESET;
0004ce  2000              MOVS     r0,#0
                  |L1.1232|
;;;698      }
;;;699      /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;700      return bitstatus; 
;;;701    }
0004d0  4770              BX       lr
;;;702    
                          ENDP

                  FLASH_ITConfig PROC
;;;713      */
;;;714    void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
0004d2  b129              CBZ      r1,|L1.1248|
;;;715    {
;;;716      /* Check the parameters */
;;;717      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;718      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;719      if(NewState != DISABLE)
;;;720      {
;;;721        /* Enable the interrupt sources */
;;;722        FLASH->CR |= FLASH_IT;
0004d4  4a12              LDR      r2,|L1.1312|
0004d6  6912              LDR      r2,[r2,#0x10]
0004d8  4302              ORRS     r2,r2,r0
0004da  4b11              LDR      r3,|L1.1312|
0004dc  611a              STR      r2,[r3,#0x10]
0004de  e004              B        |L1.1258|
                  |L1.1248|
;;;723      }
;;;724      else
;;;725      {
;;;726        /* Disable the interrupt sources */
;;;727        FLASH->CR &= ~(uint32_t)FLASH_IT;
0004e0  4a0f              LDR      r2,|L1.1312|
0004e2  6912              LDR      r2,[r2,#0x10]
0004e4  4382              BICS     r2,r2,r0
0004e6  4b0e              LDR      r3,|L1.1312|
0004e8  611a              STR      r2,[r3,#0x10]
                  |L1.1258|
;;;728      }
;;;729    }
0004ea  4770              BX       lr
;;;730    
                          ENDP

                  FLASH_GetFlagStatus PROC
;;;741      */
;;;742    FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
0004ec  4601              MOV      r1,r0
;;;743    {
;;;744      FlagStatus bitstatus = RESET;
0004ee  2000              MOVS     r0,#0
;;;745      /* Check the parameters */
;;;746      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;747      if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
0004f0  2901              CMP      r1,#1
0004f2  d108              BNE      |L1.1286|
;;;748      {
;;;749        if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
0004f4  4a0a              LDR      r2,|L1.1312|
0004f6  69d2              LDR      r2,[r2,#0x1c]
0004f8  f0020201          AND      r2,r2,#1
0004fc  b10a              CBZ      r2,|L1.1282|
;;;750        {
;;;751          bitstatus = SET;
0004fe  2001              MOVS     r0,#1
000500  e008              B        |L1.1300|
                  |L1.1282|
;;;752        }
;;;753        else
;;;754        {
;;;755          bitstatus = RESET;
000502  2000              MOVS     r0,#0
000504  e006              B        |L1.1300|
                  |L1.1286|
;;;756        }
;;;757      }
;;;758      else
;;;759      {
;;;760       if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
000506  4a06              LDR      r2,|L1.1312|
000508  68d2              LDR      r2,[r2,#0xc]
00050a  400a              ANDS     r2,r2,r1
00050c  b10a              CBZ      r2,|L1.1298|
;;;761        {
;;;762          bitstatus = SET;
00050e  2001              MOVS     r0,#1
000510  e000              B        |L1.1300|
                  |L1.1298|
;;;763        }
;;;764        else
;;;765        {
;;;766          bitstatus = RESET;
000512  2000              MOVS     r0,#0
                  |L1.1300|
;;;767        }
;;;768      }
;;;769      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;770      return bitstatus;
;;;771    }
000514  4770              BX       lr
;;;772    
                          ENDP

                  FLASH_ClearFlag PROC
;;;782      */
;;;783    void FLASH_ClearFlag(uint16_t FLASH_FLAG)
000516  4902              LDR      r1,|L1.1312|
;;;784    {
;;;785      /* Check the parameters */
;;;786      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;787      
;;;788      /* Clear the flags */
;;;789      FLASH->SR = FLASH_FLAG;
000518  60c8              STR      r0,[r1,#0xc]
;;;790    }
00051a  4770              BX       lr
;;;791    
                          ENDP

                  |L1.1308|
                          DCD      0x1ffff800
                  |L1.1312|
                          DCD      0x40022000
                  |L1.1316|
                          DCD      0x45670123
                  |L1.1320|
                          DCD      0xcdef89ab
