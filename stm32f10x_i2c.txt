; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\stm32f10x_i2c.o --asm_dir=.\ --list_dir=.\ --depend=.\obj\stm32f10x_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\FWlib\inc -I.\user -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=514 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\obj\stm32f10x_i2c.crf FWlib\SRC\stm32f10x_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;161      */
;;;162    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;163    {
000002  4604              MOV      r4,r0
;;;164      /* Check the parameters */
;;;165      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;166      switch (*(uint32_t*)&I2Cx)
000004  48f3              LDR      r0,|L1.980|
000006  4420              ADD      r0,r0,r4
000008  b118              CBZ      r0,|L1.18|
00000a  f5b06f80          CMP      r0,#0x400
00000e  d114              BNE      |L1.58|
000010  e009              B        |L1.38|
                  |L1.18|
;;;167      {
;;;168        case I2C1_BASE:
;;;169          /* Enable I2C1 reset state */
;;;170          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
000012  2101              MOVS     r1,#1
000014  0548              LSLS     r0,r1,#21
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;171          /* Release I2C1 from reset state */
;;;172          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
00001a  2100              MOVS     r1,#0
00001c  f44f1000          MOV      r0,#0x200000
000020  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;173          break;
000024  e00a              B        |L1.60|
                  |L1.38|
;;;174        case I2C2_BASE:
;;;175          /* Enable I2C2 reset state */
;;;176          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000026  2101              MOVS     r1,#1
000028  0588              LSLS     r0,r1,#22
00002a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;177          /* Release I2C2 from reset state */
;;;178          RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00002e  2100              MOVS     r1,#0
000030  f44f0080          MOV      r0,#0x400000
000034  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;179          break;
000038  e000              B        |L1.60|
                  |L1.58|
;;;180        default:
;;;181          break;
00003a  bf00              NOP      
                  |L1.60|
00003c  bf00              NOP                            ;173
;;;182      }
;;;183    }
00003e  bd10              POP      {r4,pc}
;;;184    
                          ENDP

                  I2C_Init PROC
;;;193      */
;;;194    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000040  e92d43f0          PUSH     {r4-r9,lr}
;;;195    {
000044  b085              SUB      sp,sp,#0x14
000046  4604              MOV      r4,r0
000048  460d              MOV      r5,r1
;;;196      uint16_t tmpreg = 0, freqrange = 0;
00004a  2600              MOVS     r6,#0
00004c  46b1              MOV      r9,r6
;;;197      uint16_t result = 0x04;
00004e  2704              MOVS     r7,#4
;;;198      uint32_t pclk1 = 8000000;
000050  f8df8384          LDR      r8,|L1.984|
;;;199      RCC_ClocksTypeDef  rcc_clocks;
;;;200      /* Check the parameters */
;;;201      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;202      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;203      assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
;;;204      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;205      assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
;;;206      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;207      assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
;;;208    /*---------------------------- I2Cx CR2 Configuration ------------------------*/
;;;209      /* Get the I2Cx CR2 value */
;;;210      tmpreg = I2Cx->CR2;
000054  88a6              LDRH     r6,[r4,#4]
;;;211      /* Clear frequency FREQ[5:0] bits */
;;;212      tmpreg &= CR2_FREQ_Reset;
000056  f64f70c0          MOV      r0,#0xffc0
00005a  4006              ANDS     r6,r6,r0
;;;213      /* Get pclk1 frequency value */
;;;214      RCC_GetClocksFreq(&rcc_clocks);
00005c  4668              MOV      r0,sp
00005e  f7fffffe          BL       RCC_GetClocksFreq
;;;215      pclk1 = rcc_clocks.PCLK1_Frequency;
000062  f8dd8008          LDR      r8,[sp,#8]
;;;216      /* Set frequency bits depending on pclk1 value */
;;;217      freqrange = (uint16_t)(pclk1 / 1000000);
000066  48dd              LDR      r0,|L1.988|
000068  fbb8f0f0          UDIV     r0,r8,r0
00006c  fa1ff980          UXTH     r9,r0
;;;218      tmpreg |= freqrange;
000070  ea460609          ORR      r6,r6,r9
;;;219      /* Write to I2Cx CR2 */
;;;220      I2Cx->CR2 = tmpreg;
000074  80a6              STRH     r6,[r4,#4]
;;;221    /*---------------------------- I2Cx CCR Configuration ------------------------*/
;;;222      /* Disable the selected I2C peripheral to configure TRISE */
;;;223      I2Cx->CR1 &= CR1_PE_Reset;
000076  8820              LDRH     r0,[r4,#0]
000078  f64f71fe          MOV      r1,#0xfffe
00007c  4008              ANDS     r0,r0,r1
00007e  8020              STRH     r0,[r4,#0]
;;;224      /* Reset tmpreg value */
;;;225      /* Clear F/S, DUTY and CCR[11:0] bits */
;;;226      tmpreg = 0;
000080  2600              MOVS     r6,#0
;;;227      /* Configure speed in standard mode */
;;;228      if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
000082  49d7              LDR      r1,|L1.992|
000084  68e8              LDR      r0,[r5,#0xc]
000086  4288              CMP      r0,r1
000088  d80c              BHI      |L1.164|
;;;229      {
;;;230        /* Standard mode speed calculate */
;;;231        result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
00008a  68e8              LDR      r0,[r5,#0xc]
00008c  0040              LSLS     r0,r0,#1
00008e  fbb8f0f0          UDIV     r0,r8,r0
000092  b287              UXTH     r7,r0
;;;232        /* Test if CCR value is under 0x4*/
;;;233        if (result < 0x04)
000094  2f04              CMP      r7,#4
000096  da00              BGE      |L1.154|
;;;234        {
;;;235          /* Set minimum allowed value */
;;;236          result = 0x04;  
000098  2704              MOVS     r7,#4
                  |L1.154|
;;;237        }
;;;238        /* Set speed value for standard mode */
;;;239        tmpreg |= result;	  
00009a  433e              ORRS     r6,r6,r7
;;;240        /* Set Maximum Rise Time for standard mode */
;;;241        I2Cx->TRISE = freqrange + 1; 
00009c  f1090001          ADD      r0,r9,#1
0000a0  8420              STRH     r0,[r4,#0x20]
0000a2  e027              B        |L1.244|
                  |L1.164|
;;;242      }
;;;243      /* Configure speed in fast mode */
;;;244      else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
;;;245      {
;;;246        if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
0000a4  8868              LDRH     r0,[r5,#2]
0000a6  f64b71ff          MOV      r1,#0xbfff
0000aa  4288              CMP      r0,r1
0000ac  d106              BNE      |L1.188|
;;;247        {
;;;248          /* Fast mode speed calculate: Tlow/Thigh = 2 */
;;;249          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
0000ae  68e8              LDR      r0,[r5,#0xc]
0000b0  eb000040          ADD      r0,r0,r0,LSL #1
0000b4  fbb8f0f0          UDIV     r0,r8,r0
0000b8  b287              UXTH     r7,r0
0000ba  e009              B        |L1.208|
                  |L1.188|
;;;250        }
;;;251        else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
;;;252        {
;;;253          /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
;;;254          result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
0000bc  68e8              LDR      r0,[r5,#0xc]
0000be  eb0001c0          ADD      r1,r0,r0,LSL #3
0000c2  eb011000          ADD      r0,r1,r0,LSL #4
0000c6  fbb8f0f0          UDIV     r0,r8,r0
0000ca  b287              UXTH     r7,r0
;;;255          /* Set DUTY bit */
;;;256          result |= I2C_DutyCycle_16_9;
0000cc  f4474780          ORR      r7,r7,#0x4000
                  |L1.208|
;;;257        }
;;;258        /* Test if CCR value is under 0x1*/
;;;259        if ((result & CCR_CCR_Set) == 0)
0000d0  f3c7000b          UBFX     r0,r7,#0,#12
0000d4  b908              CBNZ     r0,|L1.218|
;;;260        {
;;;261          /* Set minimum allowed value */
;;;262          result |= (uint16_t)0x0001;  
0000d6  f0470701          ORR      r7,r7,#1
                  |L1.218|
;;;263        }
;;;264        /* Set speed value and set F/S bit for fast mode */
;;;265        tmpreg |= result | CCR_FS_Set;
0000da  f4474000          ORR      r0,r7,#0x8000
0000de  4306              ORRS     r6,r6,r0
;;;266        /* Set Maximum Rise Time for fast mode */
;;;267        I2Cx->TRISE = (uint16_t)(((freqrange * 300) / 1000) + 1);  
0000e0  f44f7096          MOV      r0,#0x12c
0000e4  fb09f000          MUL      r0,r9,r0
0000e8  f44f717a          MOV      r1,#0x3e8
0000ec  fb90f0f1          SDIV     r0,r0,r1
0000f0  1c40              ADDS     r0,r0,#1
0000f2  8420              STRH     r0,[r4,#0x20]
                  |L1.244|
;;;268      }
;;;269      /* Write to I2Cx CCR */
;;;270      I2Cx->CCR = tmpreg;
0000f4  83a6              STRH     r6,[r4,#0x1c]
;;;271      /* Enable the selected I2C peripheral */
;;;272      I2Cx->CR1 |= CR1_PE_Set;
0000f6  8820              LDRH     r0,[r4,#0]
0000f8  f0400001          ORR      r0,r0,#1
0000fc  8020              STRH     r0,[r4,#0]
;;;273    /*---------------------------- I2Cx CR1 Configuration ------------------------*/
;;;274      /* Get the I2Cx CR1 value */
;;;275      tmpreg = I2Cx->CR1;
0000fe  8826              LDRH     r6,[r4,#0]
;;;276      /* Clear ACK, SMBTYPE and  SMBUS bits */
;;;277      tmpreg &= CR1_CLEAR_Mask;
000100  f64f30f5          MOV      r0,#0xfbf5
000104  4006              ANDS     r6,r6,r0
;;;278      /* Configure I2Cx: mode and acknowledgement */
;;;279      /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
;;;280      /* Set ACK bit according to I2C_Ack value */
;;;281      tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
000106  8828              LDRH     r0,[r5,#0]
000108  88e9              LDRH     r1,[r5,#6]
00010a  4308              ORRS     r0,r0,r1
00010c  4306              ORRS     r6,r6,r0
;;;282      /* Write to I2Cx CR1 */
;;;283      I2Cx->CR1 = tmpreg;
00010e  8026              STRH     r6,[r4,#0]
;;;284    /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
;;;285      /* Set I2Cx Own Address1 and acknowledged address */
;;;286      I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
000110  8928              LDRH     r0,[r5,#8]
000112  88a9              LDRH     r1,[r5,#4]
000114  4308              ORRS     r0,r0,r1
000116  8120              STRH     r0,[r4,#8]
;;;287    }
000118  b005              ADD      sp,sp,#0x14
00011a  e8bd83f0          POP      {r4-r9,pc}
;;;288    
                          ENDP

                  I2C_StructInit PROC
;;;294      */
;;;295    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
00011e  2100              MOVS     r1,#0
;;;296    {
;;;297    /*---------------- Reset I2C init structure parameters values ----------------*/
;;;298      /* Initialize the I2C_Mode member */
;;;299      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000120  8001              STRH     r1,[r0,#0]
;;;300      /* Initialize the I2C_DutyCycle member */
;;;301      I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
000122  f64b71ff          MOV      r1,#0xbfff
000126  8041              STRH     r1,[r0,#2]
;;;302      /* Initialize the I2C_OwnAddress1 member */
;;;303      I2C_InitStruct->I2C_OwnAddress1 = 0;
000128  2100              MOVS     r1,#0
00012a  8081              STRH     r1,[r0,#4]
;;;304      /* Initialize the I2C_Ack member */
;;;305      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
00012c  80c1              STRH     r1,[r0,#6]
;;;306      /* Initialize the I2C_AcknowledgedAddress member */
;;;307      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00012e  f44f4180          MOV      r1,#0x4000
000132  8101              STRH     r1,[r0,#8]
;;;308      /* initialize the I2C_ClockSpeed member */
;;;309      I2C_InitStruct->I2C_ClockSpeed = 5000;
000134  f2413188          MOV      r1,#0x1388
000138  60c1              STR      r1,[r0,#0xc]
;;;310    }
00013a  4770              BX       lr
;;;311    
                          ENDP

                  I2C_Cmd PROC
;;;318      */
;;;319    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00013c  b121              CBZ      r1,|L1.328|
;;;320    {
;;;321      /* Check the parameters */
;;;322      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;323      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;324      if (NewState != DISABLE)
;;;325      {
;;;326        /* Enable the selected I2C peripheral */
;;;327        I2Cx->CR1 |= CR1_PE_Set;
00013e  8802              LDRH     r2,[r0,#0]
000140  f0420201          ORR      r2,r2,#1
000144  8002              STRH     r2,[r0,#0]
000146  e004              B        |L1.338|
                  |L1.328|
;;;328      }
;;;329      else
;;;330      {
;;;331        /* Disable the selected I2C peripheral */
;;;332        I2Cx->CR1 &= CR1_PE_Reset;
000148  8802              LDRH     r2,[r0,#0]
00014a  f64f73fe          MOV      r3,#0xfffe
00014e  401a              ANDS     r2,r2,r3
000150  8002              STRH     r2,[r0,#0]
                  |L1.338|
;;;333      }
;;;334    }
000152  4770              BX       lr
;;;335    
                          ENDP

                  I2C_DMACmd PROC
;;;342      */
;;;343    void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000154  b121              CBZ      r1,|L1.352|
;;;344    {
;;;345      /* Check the parameters */
;;;346      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;347      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;348      if (NewState != DISABLE)
;;;349      {
;;;350        /* Enable the selected I2C DMA requests */
;;;351        I2Cx->CR2 |= CR2_DMAEN_Set;
000156  8882              LDRH     r2,[r0,#4]
000158  f4426200          ORR      r2,r2,#0x800
00015c  8082              STRH     r2,[r0,#4]
00015e  e004              B        |L1.362|
                  |L1.352|
;;;352      }
;;;353      else
;;;354      {
;;;355        /* Disable the selected I2C DMA requests */
;;;356        I2Cx->CR2 &= CR2_DMAEN_Reset;
000160  8882              LDRH     r2,[r0,#4]
000162  f24f73ff          MOV      r3,#0xf7ff
000166  401a              ANDS     r2,r2,r3
000168  8082              STRH     r2,[r0,#4]
                  |L1.362|
;;;357      }
;;;358    }
00016a  4770              BX       lr
;;;359    
                          ENDP

                  I2C_DMALastTransferCmd PROC
;;;366      */
;;;367    void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
00016c  b121              CBZ      r1,|L1.376|
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;371      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;372      if (NewState != DISABLE)
;;;373      {
;;;374        /* Next DMA transfer is the last transfer */
;;;375        I2Cx->CR2 |= CR2_LAST_Set;
00016e  8882              LDRH     r2,[r0,#4]
000170  f4425280          ORR      r2,r2,#0x1000
000174  8082              STRH     r2,[r0,#4]
000176  e004              B        |L1.386|
                  |L1.376|
;;;376      }
;;;377      else
;;;378      {
;;;379        /* Next DMA transfer is not the last transfer */
;;;380        I2Cx->CR2 &= CR2_LAST_Reset;
000178  8882              LDRH     r2,[r0,#4]
00017a  f64e73ff          MOV      r3,#0xefff
00017e  401a              ANDS     r2,r2,r3
000180  8082              STRH     r2,[r0,#4]
                  |L1.386|
;;;381      }
;;;382    }
000182  4770              BX       lr
;;;383    
                          ENDP

                  I2C_GenerateSTART PROC
;;;390      */
;;;391    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000184  b121              CBZ      r1,|L1.400|
;;;392    {
;;;393      /* Check the parameters */
;;;394      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;395      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;396      if (NewState != DISABLE)
;;;397      {
;;;398        /* Generate a START condition */
;;;399        I2Cx->CR1 |= CR1_START_Set;
000186  8802              LDRH     r2,[r0,#0]
000188  f4427280          ORR      r2,r2,#0x100
00018c  8002              STRH     r2,[r0,#0]
00018e  e004              B        |L1.410|
                  |L1.400|
;;;400      }
;;;401      else
;;;402      {
;;;403        /* Disable the START condition generation */
;;;404        I2Cx->CR1 &= CR1_START_Reset;
000190  8802              LDRH     r2,[r0,#0]
000192  f64f63ff          MOV      r3,#0xfeff
000196  401a              ANDS     r2,r2,r3
000198  8002              STRH     r2,[r0,#0]
                  |L1.410|
;;;405      }
;;;406    }
00019a  4770              BX       lr
;;;407    
                          ENDP

                  I2C_GenerateSTOP PROC
;;;414      */
;;;415    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
00019c  b121              CBZ      r1,|L1.424|
;;;416    {
;;;417      /* Check the parameters */
;;;418      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;419      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;420      if (NewState != DISABLE)
;;;421      {
;;;422        /* Generate a STOP condition */
;;;423        I2Cx->CR1 |= CR1_STOP_Set;
00019e  8802              LDRH     r2,[r0,#0]
0001a0  f4427200          ORR      r2,r2,#0x200
0001a4  8002              STRH     r2,[r0,#0]
0001a6  e004              B        |L1.434|
                  |L1.424|
;;;424      }
;;;425      else
;;;426      {
;;;427        /* Disable the STOP condition generation */
;;;428        I2Cx->CR1 &= CR1_STOP_Reset;
0001a8  8802              LDRH     r2,[r0,#0]
0001aa  f64f53ff          MOV      r3,#0xfdff
0001ae  401a              ANDS     r2,r2,r3
0001b0  8002              STRH     r2,[r0,#0]
                  |L1.434|
;;;429      }
;;;430    }
0001b2  4770              BX       lr
;;;431    
                          ENDP

                  I2C_AcknowledgeConfig PROC
;;;438      */
;;;439    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001b4  b121              CBZ      r1,|L1.448|
;;;440    {
;;;441      /* Check the parameters */
;;;442      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;443      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;444      if (NewState != DISABLE)
;;;445      {
;;;446        /* Enable the acknowledgement */
;;;447        I2Cx->CR1 |= CR1_ACK_Set;
0001b6  8802              LDRH     r2,[r0,#0]
0001b8  f4426280          ORR      r2,r2,#0x400
0001bc  8002              STRH     r2,[r0,#0]
0001be  e004              B        |L1.458|
                  |L1.448|
;;;448      }
;;;449      else
;;;450      {
;;;451        /* Disable the acknowledgement */
;;;452        I2Cx->CR1 &= CR1_ACK_Reset;
0001c0  8802              LDRH     r2,[r0,#0]
0001c2  f64f33ff          MOV      r3,#0xfbff
0001c6  401a              ANDS     r2,r2,r3
0001c8  8002              STRH     r2,[r0,#0]
                  |L1.458|
;;;453      }
;;;454    }
0001ca  4770              BX       lr
;;;455    
                          ENDP

                  I2C_OwnAddress2Config PROC
;;;461      */
;;;462    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
0001cc  460a              MOV      r2,r1
;;;463    {
;;;464      uint16_t tmpreg = 0;
0001ce  2100              MOVS     r1,#0
;;;465      /* Check the parameters */
;;;466      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;467      /* Get the old register value */
;;;468      tmpreg = I2Cx->OAR2;
0001d0  8981              LDRH     r1,[r0,#0xc]
;;;469      /* Reset I2Cx Own address2 bit [7:1] */
;;;470      tmpreg &= OAR2_ADD2_Reset;
0001d2  f64f7301          MOV      r3,#0xff01
0001d6  4019              ANDS     r1,r1,r3
;;;471      /* Set I2Cx Own address2 */
;;;472      tmpreg |= (uint16_t)(Address & (uint16_t)0x00FE);
0001d8  f00203fe          AND      r3,r2,#0xfe
0001dc  4319              ORRS     r1,r1,r3
;;;473      /* Store the new register value */
;;;474      I2Cx->OAR2 = tmpreg;
0001de  8181              STRH     r1,[r0,#0xc]
;;;475    }
0001e0  4770              BX       lr
;;;476    
                          ENDP

                  I2C_DualAddressCmd PROC
;;;483      */
;;;484    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001e2  b121              CBZ      r1,|L1.494|
;;;485    {
;;;486      /* Check the parameters */
;;;487      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;488      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;489      if (NewState != DISABLE)
;;;490      {
;;;491        /* Enable dual addressing mode */
;;;492        I2Cx->OAR2 |= OAR2_ENDUAL_Set;
0001e4  8982              LDRH     r2,[r0,#0xc]
0001e6  f0420201          ORR      r2,r2,#1
0001ea  8182              STRH     r2,[r0,#0xc]
0001ec  e004              B        |L1.504|
                  |L1.494|
;;;493      }
;;;494      else
;;;495      {
;;;496        /* Disable dual addressing mode */
;;;497        I2Cx->OAR2 &= OAR2_ENDUAL_Reset;
0001ee  8982              LDRH     r2,[r0,#0xc]
0001f0  f64f73fe          MOV      r3,#0xfffe
0001f4  401a              ANDS     r2,r2,r3
0001f6  8182              STRH     r2,[r0,#0xc]
                  |L1.504|
;;;498      }
;;;499    }
0001f8  4770              BX       lr
;;;500    
                          ENDP

                  I2C_GeneralCallCmd PROC
;;;507      */
;;;508    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0001fa  b121              CBZ      r1,|L1.518|
;;;509    {
;;;510      /* Check the parameters */
;;;511      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;512      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;513      if (NewState != DISABLE)
;;;514      {
;;;515        /* Enable generall call */
;;;516        I2Cx->CR1 |= CR1_ENGC_Set;
0001fc  8802              LDRH     r2,[r0,#0]
0001fe  f0420240          ORR      r2,r2,#0x40
000202  8002              STRH     r2,[r0,#0]
000204  e004              B        |L1.528|
                  |L1.518|
;;;517      }
;;;518      else
;;;519      {
;;;520        /* Disable generall call */
;;;521        I2Cx->CR1 &= CR1_ENGC_Reset;
000206  8802              LDRH     r2,[r0,#0]
000208  f64f73bf          MOV      r3,#0xffbf
00020c  401a              ANDS     r2,r2,r3
00020e  8002              STRH     r2,[r0,#0]
                  |L1.528|
;;;522      }
;;;523    }
000210  4770              BX       lr
;;;524    
                          ENDP

                  I2C_ITConfig PROC
;;;537      */
;;;538    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
000212  b11a              CBZ      r2,|L1.540|
;;;539    {
;;;540      /* Check the parameters */
;;;541      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;542      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;543      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;544      
;;;545      if (NewState != DISABLE)
;;;546      {
;;;547        /* Enable the selected I2C interrupts */
;;;548        I2Cx->CR2 |= I2C_IT;
000214  8883              LDRH     r3,[r0,#4]
000216  430b              ORRS     r3,r3,r1
000218  8083              STRH     r3,[r0,#4]
00021a  e002              B        |L1.546|
                  |L1.540|
;;;549      }
;;;550      else
;;;551      {
;;;552        /* Disable the selected I2C interrupts */
;;;553        I2Cx->CR2 &= (uint16_t)~I2C_IT;
00021c  8883              LDRH     r3,[r0,#4]
00021e  438b              BICS     r3,r3,r1
000220  8083              STRH     r3,[r0,#4]
                  |L1.546|
;;;554      }
;;;555    }
000222  4770              BX       lr
;;;556    
                          ENDP

                  I2C_SendData PROC
;;;562      */
;;;563    void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000224  8201              STRH     r1,[r0,#0x10]
;;;564    {
;;;565      /* Check the parameters */
;;;566      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;567      /* Write in the DR register the data to be sent */
;;;568      I2Cx->DR = Data;
;;;569    }
000226  4770              BX       lr
;;;570    
                          ENDP

                  I2C_ReceiveData PROC
;;;575      */
;;;576    uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000228  4601              MOV      r1,r0
;;;577    {
;;;578      /* Check the parameters */
;;;579      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;580      /* Return the data in the DR register */
;;;581      return (uint8_t)I2Cx->DR;
00022a  8a08              LDRH     r0,[r1,#0x10]
00022c  b2c0              UXTB     r0,r0
;;;582    }
00022e  4770              BX       lr
;;;583    
                          ENDP

                  I2C_Send7bitAddress PROC
;;;594      */
;;;595    void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
000230  b112              CBZ      r2,|L1.568|
;;;596    {
;;;597      /* Check the parameters */
;;;598      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;599      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;600      /* Test on the direction to set/reset the read/write bit */
;;;601      if (I2C_Direction != I2C_Direction_Transmitter)
;;;602      {
;;;603        /* Set the address bit0 for read */
;;;604        Address |= OAR1_ADD0_Set;
000232  f0410101          ORR      r1,r1,#1
000236  e002              B        |L1.574|
                  |L1.568|
;;;605      }
;;;606      else
;;;607      {
;;;608        /* Reset the address bit0 for write */
;;;609        Address &= OAR1_ADD0_Reset;
000238  f64f73fe          MOV      r3,#0xfffe
00023c  4019              ANDS     r1,r1,r3
                  |L1.574|
;;;610      }
;;;611      /* Send the address */
;;;612      I2Cx->DR = Address;
00023e  8201              STRH     r1,[r0,#0x10]
;;;613    }
000240  4770              BX       lr
;;;614    
                          ENDP

                  I2C_ReadRegister PROC
;;;629      */
;;;630    uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000242  4602              MOV      r2,r0
;;;631    {
;;;632      /* Check the parameters */
;;;633      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;634      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;635      /* Return the selected register value */
;;;636      return (*(__IO uint16_t *)(*((__IO uint32_t *)&I2Cx) + I2C_Register));
000244  5a50              LDRH     r0,[r2,r1]
;;;637    }
000246  4770              BX       lr
;;;638    
                          ENDP

                  I2C_SoftwareResetCmd PROC
;;;645      */
;;;646    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000248  b121              CBZ      r1,|L1.596|
;;;647    {
;;;648      /* Check the parameters */
;;;649      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;650      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;651      if (NewState != DISABLE)
;;;652      {
;;;653        /* Peripheral under reset */
;;;654        I2Cx->CR1 |= CR1_SWRST_Set;
00024a  8802              LDRH     r2,[r0,#0]
00024c  f4424200          ORR      r2,r2,#0x8000
000250  8002              STRH     r2,[r0,#0]
000252  e003              B        |L1.604|
                  |L1.596|
;;;655      }
;;;656      else
;;;657      {
;;;658        /* Peripheral not under reset */
;;;659        I2Cx->CR1 &= CR1_SWRST_Reset;
000254  8802              LDRH     r2,[r0,#0]
000256  f3c2020e          UBFX     r2,r2,#0,#15
00025a  8002              STRH     r2,[r0,#0]
                  |L1.604|
;;;660      }
;;;661    }
00025c  4770              BX       lr
;;;662    
                          ENDP

                  I2C_SMBusAlertConfig PROC
;;;671      */
;;;672    void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
00025e  f5b15f00          CMP      r1,#0x2000
;;;673    {
;;;674      /* Check the parameters */
;;;675      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;676      assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
;;;677      if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
000262  d104              BNE      |L1.622|
;;;678      {
;;;679        /* Drive the SMBusAlert pin Low */
;;;680        I2Cx->CR1 |= I2C_SMBusAlert_Low;
000264  8802              LDRH     r2,[r0,#0]
000266  f4425200          ORR      r2,r2,#0x2000
00026a  8002              STRH     r2,[r0,#0]
00026c  e004              B        |L1.632|
                  |L1.622|
;;;681      }
;;;682      else
;;;683      {
;;;684        /* Drive the SMBusAlert pin High  */
;;;685        I2Cx->CR1 &= I2C_SMBusAlert_High;
00026e  8802              LDRH     r2,[r0,#0]
000270  f64d73ff          MOV      r3,#0xdfff
000274  401a              ANDS     r2,r2,r3
000276  8002              STRH     r2,[r0,#0]
                  |L1.632|
;;;686      }
;;;687    }
000278  4770              BX       lr
;;;688    
                          ENDP

                  I2C_TransmitPEC PROC
;;;695      */
;;;696    void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
00027a  b121              CBZ      r1,|L1.646|
;;;697    {
;;;698      /* Check the parameters */
;;;699      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;700      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;701      if (NewState != DISABLE)
;;;702      {
;;;703        /* Enable the selected I2C PEC transmission */
;;;704        I2Cx->CR1 |= CR1_PEC_Set;
00027c  8802              LDRH     r2,[r0,#0]
00027e  f4425280          ORR      r2,r2,#0x1000
000282  8002              STRH     r2,[r0,#0]
000284  e004              B        |L1.656|
                  |L1.646|
;;;705      }
;;;706      else
;;;707      {
;;;708        /* Disable the selected I2C PEC transmission */
;;;709        I2Cx->CR1 &= CR1_PEC_Reset;
000286  8802              LDRH     r2,[r0,#0]
000288  f64e73ff          MOV      r3,#0xefff
00028c  401a              ANDS     r2,r2,r3
00028e  8002              STRH     r2,[r0,#0]
                  |L1.656|
;;;710      }
;;;711    }
000290  4770              BX       lr
;;;712    
                          ENDP

                  I2C_PECPositionConfig PROC
;;;723      */
;;;724    void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
000292  f5b16f00          CMP      r1,#0x800
;;;725    {
;;;726      /* Check the parameters */
;;;727      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;728      assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
;;;729      if (I2C_PECPosition == I2C_PECPosition_Next)
000296  d104              BNE      |L1.674|
;;;730      {
;;;731        /* Next byte in shift register is PEC */
;;;732        I2Cx->CR1 |= I2C_PECPosition_Next;
000298  8802              LDRH     r2,[r0,#0]
00029a  f4426200          ORR      r2,r2,#0x800
00029e  8002              STRH     r2,[r0,#0]
0002a0  e004              B        |L1.684|
                  |L1.674|
;;;733      }
;;;734      else
;;;735      {
;;;736        /* Current byte in shift register is PEC */
;;;737        I2Cx->CR1 &= I2C_PECPosition_Current;
0002a2  8802              LDRH     r2,[r0,#0]
0002a4  f24f73ff          MOV      r3,#0xf7ff
0002a8  401a              ANDS     r2,r2,r3
0002aa  8002              STRH     r2,[r0,#0]
                  |L1.684|
;;;738      }
;;;739    }
0002ac  4770              BX       lr
;;;740    
                          ENDP

                  I2C_CalculatePEC PROC
;;;748      */
;;;749    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002ae  b121              CBZ      r1,|L1.698|
;;;750    {
;;;751      /* Check the parameters */
;;;752      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;753      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;754      if (NewState != DISABLE)
;;;755      {
;;;756        /* Enable the selected I2C PEC calculation */
;;;757        I2Cx->CR1 |= CR1_ENPEC_Set;
0002b0  8802              LDRH     r2,[r0,#0]
0002b2  f0420220          ORR      r2,r2,#0x20
0002b6  8002              STRH     r2,[r0,#0]
0002b8  e004              B        |L1.708|
                  |L1.698|
;;;758      }
;;;759      else
;;;760      {
;;;761        /* Disable the selected I2C PEC calculation */
;;;762        I2Cx->CR1 &= CR1_ENPEC_Reset;
0002ba  8802              LDRH     r2,[r0,#0]
0002bc  f64f73df          MOV      r3,#0xffdf
0002c0  401a              ANDS     r2,r2,r3
0002c2  8002              STRH     r2,[r0,#0]
                  |L1.708|
;;;763      }
;;;764    }
0002c4  4770              BX       lr
;;;765    
                          ENDP

                  I2C_GetPEC PROC
;;;770      */
;;;771    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
0002c6  4601              MOV      r1,r0
;;;772    {
;;;773      /* Check the parameters */
;;;774      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;775      /* Return the selected I2C PEC value */
;;;776      return ((I2Cx->SR2) >> 8);
0002c8  8b08              LDRH     r0,[r1,#0x18]
0002ca  1200              ASRS     r0,r0,#8
;;;777    }
0002cc  4770              BX       lr
;;;778    
                          ENDP

                  I2C_ARPCmd PROC
;;;785      */
;;;786    void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002ce  b121              CBZ      r1,|L1.730|
;;;787    {
;;;788      /* Check the parameters */
;;;789      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;790      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;791      if (NewState != DISABLE)
;;;792      {
;;;793        /* Enable the selected I2C ARP */
;;;794        I2Cx->CR1 |= CR1_ENARP_Set;
0002d0  8802              LDRH     r2,[r0,#0]
0002d2  f0420210          ORR      r2,r2,#0x10
0002d6  8002              STRH     r2,[r0,#0]
0002d8  e004              B        |L1.740|
                  |L1.730|
;;;795      }
;;;796      else
;;;797      {
;;;798        /* Disable the selected I2C ARP */
;;;799        I2Cx->CR1 &= CR1_ENARP_Reset;
0002da  8802              LDRH     r2,[r0,#0]
0002dc  f64f73ef          MOV      r3,#0xffef
0002e0  401a              ANDS     r2,r2,r3
0002e2  8002              STRH     r2,[r0,#0]
                  |L1.740|
;;;800      }
;;;801    }
0002e4  4770              BX       lr
;;;802    
                          ENDP

                  I2C_StretchClockCmd PROC
;;;809      */
;;;810    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
0002e6  b921              CBNZ     r1,|L1.754|
;;;811    {
;;;812      /* Check the parameters */
;;;813      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;814      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;815      if (NewState == DISABLE)
;;;816      {
;;;817        /* Enable the selected I2C Clock stretching */
;;;818        I2Cx->CR1 |= CR1_NOSTRETCH_Set;
0002e8  8802              LDRH     r2,[r0,#0]
0002ea  f0420280          ORR      r2,r2,#0x80
0002ee  8002              STRH     r2,[r0,#0]
0002f0  e004              B        |L1.764|
                  |L1.754|
;;;819      }
;;;820      else
;;;821      {
;;;822        /* Disable the selected I2C Clock stretching */
;;;823        I2Cx->CR1 &= CR1_NOSTRETCH_Reset;
0002f2  8802              LDRH     r2,[r0,#0]
0002f4  f64f737f          MOV      r3,#0xff7f
0002f8  401a              ANDS     r2,r2,r3
0002fa  8002              STRH     r2,[r0,#0]
                  |L1.764|
;;;824      }
;;;825    }
0002fc  4770              BX       lr
;;;826    
                          ENDP

                  I2C_FastModeDutyCycleConfig PROC
;;;835      */
;;;836    void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
0002fe  f5b14f80          CMP      r1,#0x4000
;;;837    {
;;;838      /* Check the parameters */
;;;839      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;840      assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
;;;841      if (I2C_DutyCycle != I2C_DutyCycle_16_9)
000302  d005              BEQ      |L1.784|
;;;842      {
;;;843        /* I2C fast mode Tlow/Thigh=2 */
;;;844        I2Cx->CCR &= I2C_DutyCycle_2;
000304  8b82              LDRH     r2,[r0,#0x1c]
000306  f64b73ff          MOV      r3,#0xbfff
00030a  401a              ANDS     r2,r2,r3
00030c  8382              STRH     r2,[r0,#0x1c]
00030e  e003              B        |L1.792|
                  |L1.784|
;;;845      }
;;;846      else
;;;847      {
;;;848        /* I2C fast mode Tlow/Thigh=16/9 */
;;;849        I2Cx->CCR |= I2C_DutyCycle_16_9;
000310  8b82              LDRH     r2,[r0,#0x1c]
000312  f4424280          ORR      r2,r2,#0x4000
000316  8382              STRH     r2,[r0,#0x1c]
                  |L1.792|
;;;850      }
;;;851    }
000318  4770              BX       lr
;;;852    
                          ENDP

                  I2C_GetLastEvent PROC
;;;857      */
;;;858    uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
00031a  b510              PUSH     {r4,lr}
;;;859    {
00031c  4601              MOV      r1,r0
;;;860      uint32_t lastevent = 0;
00031e  2000              MOVS     r0,#0
;;;861      uint32_t flag1 = 0, flag2 = 0;
000320  2300              MOVS     r3,#0
000322  2200              MOVS     r2,#0
;;;862      /* Check the parameters */
;;;863      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;864      /* Read the I2Cx status register */
;;;865      flag1 = I2Cx->SR1;
000324  8a8b              LDRH     r3,[r1,#0x14]
;;;866      flag2 = I2Cx->SR2;
000326  8b0a              LDRH     r2,[r1,#0x18]
;;;867      flag2 = flag2 << 16;
000328  0412              LSLS     r2,r2,#16
;;;868      /* Get the last event value from I2C status register */
;;;869      lastevent = (flag1 | flag2) & FLAG_Mask;
00032a  ea430402          ORR      r4,r3,r2
00032e  f024407f          BIC      r0,r4,#0xff000000
;;;870      /* Return status */
;;;871      return lastevent;
;;;872    }
000332  bd10              POP      {r4,pc}
;;;873    
                          ENDP

                  I2C_CheckEvent PROC
;;;893      */
;;;894    ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
000334  b570              PUSH     {r4-r6,lr}
;;;895    {
000336  4602              MOV      r2,r0
;;;896      uint32_t lastevent = 0;
000338  2400              MOVS     r4,#0
;;;897      uint32_t flag1 = 0, flag2 = 0;
00033a  2500              MOVS     r5,#0
00033c  2300              MOVS     r3,#0
;;;898      ErrorStatus status = ERROR;
00033e  2000              MOVS     r0,#0
;;;899      /* Check the parameters */
;;;900      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;901      assert_param(IS_I2C_EVENT(I2C_EVENT));
;;;902      /* Read the I2Cx status register */
;;;903      flag1 = I2Cx->SR1;
000340  8a95              LDRH     r5,[r2,#0x14]
;;;904      flag2 = I2Cx->SR2;
000342  8b13              LDRH     r3,[r2,#0x18]
;;;905      flag2 = flag2 << 16;
000344  041b              LSLS     r3,r3,#16
;;;906      /* Get the last event value from I2C status register */
;;;907      lastevent = (flag1 | flag2) & FLAG_Mask;
000346  ea450603          ORR      r6,r5,r3
00034a  f026447f          BIC      r4,r6,#0xff000000
;;;908      /* Check whether the last event is equal to I2C_EVENT */
;;;909      if (lastevent == I2C_EVENT )
00034e  428c              CMP      r4,r1
000350  d101              BNE      |L1.854|
;;;910      {
;;;911        /* SUCCESS: last event is equal to I2C_EVENT */
;;;912        status = SUCCESS;
000352  2001              MOVS     r0,#1
000354  e000              B        |L1.856|
                  |L1.854|
;;;913      }
;;;914      else
;;;915      {
;;;916        /* ERROR: last event is different from I2C_EVENT */
;;;917        status = ERROR;
000356  2000              MOVS     r0,#0
                  |L1.856|
;;;918      }
;;;919      /* Return status */
;;;920      return status;
;;;921    }
000358  bd70              POP      {r4-r6,pc}
;;;922    
                          ENDP

                  I2C_GetFlagStatus PROC
;;;951      */
;;;952    FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
00035a  b50c              PUSH     {r2,r3,lr}
;;;953    {
00035c  4602              MOV      r2,r0
;;;954      FlagStatus bitstatus = RESET;
00035e  2000              MOVS     r0,#0
;;;955      __IO uint32_t i2creg = 0, i2cxbase = 0;
000360  2300              MOVS     r3,#0
000362  9301              STR      r3,[sp,#4]
000364  9300              STR      r3,[sp,#0]
;;;956      /* Check the parameters */
;;;957      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;958      assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;959      /* Get the I2Cx peripheral base address */
;;;960      i2cxbase = (*(uint32_t*)&(I2Cx));
000366  9200              STR      r2,[sp,#0]
;;;961      
;;;962      /* Read flag register index */
;;;963      i2creg = I2C_FLAG >> 28;
000368  0f0b              LSRS     r3,r1,#28
00036a  9301              STR      r3,[sp,#4]
;;;964      
;;;965      /* Get bit[23:0] of the flag */
;;;966      I2C_FLAG &= FLAG_Mask;
00036c  f021417f          BIC      r1,r1,#0xff000000
;;;967      
;;;968      if(i2creg != 0)
000370  9b01              LDR      r3,[sp,#4]
000372  b11b              CBZ      r3,|L1.892|
;;;969      {
;;;970        /* Get the I2Cx SR1 register address */
;;;971        i2cxbase += 0x14;
000374  9b00              LDR      r3,[sp,#0]
000376  3314              ADDS     r3,r3,#0x14
000378  9300              STR      r3,[sp,#0]
00037a  e003              B        |L1.900|
                  |L1.892|
;;;972      }
;;;973      else
;;;974      {
;;;975        /* Flag in I2Cx SR2 Register */
;;;976        I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
00037c  0c09              LSRS     r1,r1,#16
;;;977        /* Get the I2Cx SR2 register address */
;;;978        i2cxbase += 0x18;
00037e  9b00              LDR      r3,[sp,#0]
000380  3318              ADDS     r3,r3,#0x18
000382  9300              STR      r3,[sp,#0]
                  |L1.900|
;;;979      }
;;;980      
;;;981      if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
000384  9b00              LDR      r3,[sp,#0]
000386  681b              LDR      r3,[r3,#0]
000388  400b              ANDS     r3,r3,r1
00038a  b10b              CBZ      r3,|L1.912|
;;;982      {
;;;983        /* I2C_FLAG is set */
;;;984        bitstatus = SET;
00038c  2001              MOVS     r0,#1
00038e  e000              B        |L1.914|
                  |L1.912|
;;;985      }
;;;986      else
;;;987      {
;;;988        /* I2C_FLAG is reset */
;;;989        bitstatus = RESET;
000390  2000              MOVS     r0,#0
                  |L1.914|
;;;990      }
;;;991      
;;;992      /* Return the I2C_FLAG status */
;;;993      return  bitstatus;
;;;994    }
000392  bd0c              POP      {r2,r3,pc}
;;;995    
                          ENDP

                  I2C_ClearFlag PROC
;;;1026     */
;;;1027   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000394  2200              MOVS     r2,#0
;;;1028   {
;;;1029     uint32_t flagpos = 0;
;;;1030     /* Check the parameters */
;;;1031     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1032     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1033     /* Get the I2C flag position */
;;;1034     flagpos = I2C_FLAG & FLAG_Mask;
000396  f021427f          BIC      r2,r1,#0xff000000
;;;1035     /* Clear the selected I2C flag */
;;;1036     I2Cx->SR1 = (uint16_t)~flagpos;
00039a  43d3              MVNS     r3,r2
00039c  8283              STRH     r3,[r0,#0x14]
;;;1037   }
00039e  4770              BX       lr
;;;1038   
                          ENDP

                  I2C_GetITStatus PROC
;;;1060     */
;;;1061   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
0003a0  b530              PUSH     {r4,r5,lr}
;;;1062   {
0003a2  4602              MOV      r2,r0
;;;1063     ITStatus bitstatus = RESET;
0003a4  2000              MOVS     r0,#0
;;;1064     uint32_t enablestatus = 0;
0003a6  2300              MOVS     r3,#0
;;;1065     /* Check the parameters */
;;;1066     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1067     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1068     /* Check if the interrupt source is enabled or not */
;;;1069     enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;  
0003a8  8894              LDRH     r4,[r2,#4]
0003aa  f00165e0          AND      r5,r1,#0x7000000
0003ae  ea044315          AND      r3,r4,r5,LSR #16
;;;1070     /* Get bit[23:0] of the flag */
;;;1071     I2C_IT &= FLAG_Mask;
0003b2  f021417f          BIC      r1,r1,#0xff000000
;;;1072     /* Check the status of the specified I2C flag */
;;;1073     if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
0003b6  8a94              LDRH     r4,[r2,#0x14]
0003b8  400c              ANDS     r4,r4,r1
0003ba  b114              CBZ      r4,|L1.962|
0003bc  b10b              CBZ      r3,|L1.962|
;;;1074     {
;;;1075       /* I2C_IT is set */
;;;1076       bitstatus = SET;
0003be  2001              MOVS     r0,#1
0003c0  e000              B        |L1.964|
                  |L1.962|
;;;1077     }
;;;1078     else
;;;1079     {
;;;1080       /* I2C_IT is reset */
;;;1081       bitstatus = RESET;
0003c2  2000              MOVS     r0,#0
                  |L1.964|
;;;1082     }
;;;1083     /* Return the I2C_IT status */
;;;1084     return  bitstatus;
;;;1085   }
0003c4  bd30              POP      {r4,r5,pc}
;;;1086   
                          ENDP

                  I2C_ClearITPendingBit PROC
;;;1117     */
;;;1118   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
0003c6  2200              MOVS     r2,#0
;;;1119   {
;;;1120     uint32_t flagpos = 0;
;;;1121     /* Check the parameters */
;;;1122     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1123     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1124     /* Get the I2C flag position */
;;;1125     flagpos = I2C_IT & FLAG_Mask;
0003c8  f021427f          BIC      r2,r1,#0xff000000
;;;1126     /* Clear the selected I2C flag */
;;;1127     I2Cx->SR1 = (uint16_t)~flagpos;
0003cc  43d3              MVNS     r3,r2
0003ce  8283              STRH     r3,[r0,#0x14]
;;;1128   }
0003d0  4770              BX       lr
;;;1129   
                          ENDP

0003d2  0000              DCW      0x0000
                  |L1.980|
                          DCD      0xbfffac00
                  |L1.984|
                          DCD      0x007a1200
                  |L1.988|
                          DCD      0x000f4240
                  |L1.992|
                          DCD      0x000186a0
